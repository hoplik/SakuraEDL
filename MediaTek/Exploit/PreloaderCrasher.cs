// ============================================================================
// SakuraEDL - MediaTek Preloader Crasher
// Based on mtkclient by B.Kerler (GPLv3)
// ============================================================================
//
// ═══════════════════════════════════════════════════════════════════════════
// ★★★ 老芯片 Preloader 模式的漏洞利用策略 ★★★
// ═══════════════════════════════════════════════════════════════════════════
//
// 问题: Kamakiri/Kamakiri2 漏洞只能在 BROM 模式 (PID=0x0003) 下使用
// 解决: 让 Preloader 崩溃，触发看门狗重启进入 BROM 模式
//
// ┌────────────────────────────────────────────────────────────────────────┐
// │                     Crash to BROM 流程图                               │
// ├────────────────────────────────────────────────────────────────────────┤
// │                                                                        │
// │   [Preloader 模式]  ──────────────────►  [BROM 模式]                   │
// │   PID = 0x2000                          PID = 0x0003                  │
// │                                                                        │
// │       │                                       │                        │
// │       │ 1. 发送 Crash 命令                    │ 4. 使用 Kamakiri2      │
// │       ▼                                       ▼                        │
// │   ┌─────────────┐                      ┌─────────────┐                │
// │   │ Preloader   │   2. 触发异常        │   BROM      │                │
// │   │   崩溃      │ ──────────────────►  │   漏洞可用  │                │
// │   └─────────────┘                      └─────────────┘                │
// │                                                                        │
// │       │                                                               │
// │       │ 3. 看门狗重启                                                  │
// │       ▼                                                               │
// │   设备断开重连，PID 变为 0x0003                                        │
// │                                                                        │
// └────────────────────────────────────────────────────────────────────────┘
//
// Crash 方法说明:
// ─────────────────────────────────────────────────────────────────────────
// Mode 0: send_da(0, 0x100, 0x100, 空数据) - 向地址 0 发送无效 DA
// Mode 1: read32(0, 0x100) - 读取非法地址触发异常
// Mode 2: send_da + jump_da - 发送并执行无效 payload
// Mode 3: reset_to_brom - 设置 USBDL 寄存器触发看门狗重启
//
// 重要: 这些方法可以通过串口执行，不需要 libusb！
// ═══════════════════════════════════════════════════════════════════════════

using System;
using System.Threading;
using System.Threading.Tasks;
using SakuraEDL.MediaTek.Protocol;
using SakuraEDL.MediaTek.Database;

namespace SakuraEDL.MediaTek.Exploit
{
    /// <summary>
    /// Preloader Crasher - 让设备从 Preloader 模式崩溃进入 BROM 模式
    /// 这样就可以使用 Kamakiri/Kamakiri2 漏洞
    /// </summary>
    public class PreloaderCrasher
    {
        private readonly BromClient _brom;
        private readonly Action<string> _log;

        // USBDL 寄存器常量
        private const uint USBDL_BIT_EN = 0x00000001;
        private const uint USBDL_BROM = 0x00000002;
        private const uint USBDL_TIMEOUT_MASK = 0x0000FFFC;
        private const uint USBDL_TIMEOUT_MAX = USBDL_TIMEOUT_MASK >> 2;
        private const uint USBDL_MAGIC = 0x444C0000;
        private const uint MISC_LOCK_KEY_MAGIC = 0xAD98;

        public string LastError { get; private set; }

        public PreloaderCrasher(BromClient brom, Action<string> log = null)
        {
            _brom = brom;
            _log = log ?? delegate { };
        }

        /// <summary>
        /// 尝试所有 Crash 方法让设备进入 BROM 模式
        /// </summary>
        /// <returns>成功返回 true (设备将断开连接，需要重新连接)</returns>
        public async Task<bool> CrashToBromAsync(CancellationToken ct = default)
        {
            _log("[Crasher] 尝试让 Preloader 崩溃以进入 BROM 模式...");

            // 依次尝试不同的 Crash 方法
            for (int mode = 0; mode <= 3; mode++)
            {
                if (ct.IsCancellationRequested) return false;

                _log($"[Crasher] 尝试 Crash 方法 {mode}...");

                try
                {
                    bool result = mode switch
                    {
                        0 => await CrashMode0Async(ct),
                        1 => await CrashMode1Async(ct),
                        2 => await CrashMode2Async(ct),
                        3 => await CrashMode3Async(ct),
                        _ => false
                    };

                    if (result)
                    {
                        _log($"[Crasher] ✓ Crash 方法 {mode} 执行成功，设备应该会重启到 BROM 模式");
                        _log("[Crasher] 请等待设备重新连接 (PID 应该变为 0x0003)");
                        return true;
                    }
                }
                catch (Exception ex)
                {
                    _log($"[Crasher] Crash 方法 {mode} 异常: {ex.Message}");
                    // 异常可能是好事 - 说明设备已经崩溃
                    if (ex.Message.Contains("timeout") || ex.Message.Contains("disconnected"))
                    {
                        _log("[Crasher] ✓ 设备可能已经崩溃，等待重新连接...");
                        return true;
                    }
                }

                await Task.Delay(100, ct);
            }

            LastError = "所有 Crash 方法都失败了";
            _log($"[Crasher] ❌ {LastError}");
            return false;
        }

        /// <summary>
        /// Crash 方法 0: 发送无效的 DA 数据到地址 0
        /// </summary>
        private async Task<bool> CrashMode0Async(CancellationToken ct)
        {
            _log("[Crasher] Mode 0: 发送无效 DA 到地址 0...");

            try
            {
                // 发送 DA 命令 (0xD7)
                await _brom.EchoByteAsync(0xD7, ct);

                // 目标地址 = 0
                var addrBytes = new byte[4];
                await _brom.EchoBytesAsync(addrBytes, ct);

                // 大小 = 0x100
                var sizeBytes = BitConverter.GetBytes((uint)0x100);
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(sizeBytes);
                await _brom.EchoBytesAsync(sizeBytes, ct);

                // 签名长度 = 0x100
                await _brom.EchoBytesAsync(sizeBytes, ct);

                // 读取状态
                await _brom.ReadBytesAsync(2, 500, ct);

                // 发送空数据
                var emptyData = new byte[0x100];
                await _brom.WriteBytesAsync(emptyData, ct);

                return true;
            }
            catch
            {
                return true; // 异常也算成功 (设备可能已断开)
            }
        }

        /// <summary>
        /// Crash 方法 1: 读取非法地址 0
        /// </summary>
        private async Task<bool> CrashMode1Async(CancellationToken ct)
        {
            _log("[Crasher] Mode 1: 读取非法地址 0...");

            try
            {
                // 发送 READ32 命令 (0xD1)
                await _brom.EchoByteAsync(0xD1, ct);

                // 地址 = 0
                var addrBytes = new byte[4];
                await _brom.EchoBytesAsync(addrBytes, ct);

                // 长度 = 0x100
                var countBytes = BitConverter.GetBytes((uint)0x100);
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(countBytes);
                await _brom.EchoBytesAsync(countBytes, ct);

                // 尝试读取 (应该会失败)
                await _brom.ReadBytesAsync(0x400, 500, ct);

                return true;
            }
            catch
            {
                return true;
            }
        }

        /// <summary>
        /// Crash 方法 2: 发送并跳转到无效 payload
        /// </summary>
        private async Task<bool> CrashMode2Async(CancellationToken ct)
        {
            _log("[Crasher] Mode 2: 发送并跳转到无效 payload...");

            try
            {
                // ARM 无效指令 payload
                // LDR PC, [PC, #0] ; 跳转到无效地址
                // BX LR
                var payload = new byte[] {
                    0x00, 0x01, 0x9F, 0xE5,  // LDR R0, [PC, #-4]
                    0x10, 0xFF, 0x2F, 0xE1   // BX LR
                };

                // 填充到 0x110 字节
                var fullPayload = new byte[0x110];
                Array.Copy(payload, fullPayload, payload.Length);

                // 发送 DA
                await _brom.EchoByteAsync(0xD7, ct);

                // 地址 = 0
                var addrBytes = new byte[4];
                await _brom.EchoBytesAsync(addrBytes, ct);

                // 大小
                var sizeBytes = BitConverter.GetBytes((uint)fullPayload.Length);
                if (BitConverter.IsLittleEndian)
                    Array.Reverse(sizeBytes);
                await _brom.EchoBytesAsync(sizeBytes, ct);

                // 签名长度 = 0
                var zeroBytes = new byte[4];
                await _brom.EchoBytesAsync(zeroBytes, ct);

                // 读取状态
                await _brom.ReadBytesAsync(2, 500, ct);

                // 发送 payload
                await _brom.WriteBytesAsync(fullPayload, ct);

                // 读取状态
                await _brom.ReadBytesAsync(2, 500, ct);

                // 跳转到 DA (0xD5)
                await _brom.EchoByteAsync(0xD5, ct);
                await _brom.EchoBytesAsync(addrBytes, ct);

                return true;
            }
            catch
            {
                return true;
            }
        }

        /// <summary>
        /// Crash 方法 3: 设置 USBDL 寄存器触发看门狗重启到 BROM
        /// 这是最可靠的方法，但需要知道芯片的 misc_lock 地址
        /// </summary>
        private async Task<bool> CrashMode3Async(CancellationToken ct)
        {
            _log("[Crasher] Mode 3: 设置 USBDL 寄存器...");

            try
            {
                var hwCode = _brom.HwCode;
                var chip = MtkChipDatabase.GetChip(hwCode);

                if (chip == null || chip.MiscLockAddr == 0)
                {
                    _log("[Crasher] 无法获取 misc_lock 地址，跳过 Mode 3");
                    return false;
                }

                uint miscLock = chip.MiscLockAddr;
                uint rstCon = miscLock + 8;
                uint usbdlFlag = miscLock - 0x20;

                // 计算 USBDL 寄存器值
                uint usbdlReg = (USBDL_TIMEOUT_MAX << 2) & USBDL_TIMEOUT_MASK;
                usbdlReg |= USBDL_BIT_EN;
                usbdlReg &= ~USBDL_BROM;
                usbdlReg |= USBDL_MAGIC;

                _log($"[Crasher] misc_lock=0x{miscLock:X8}, usbdl_reg=0x{usbdlReg:X8}");

                // 解锁 MISC
                await Write32Async(miscLock, MISC_LOCK_KEY_MAGIC, ct);

                // 设置 RST_CON
                await Write32Async(rstCon, 1, ct);

                // 锁定 MISC
                await Write32Async(miscLock, 0, ct);

                // 设置 USBDL flag
                await Write32Async(usbdlFlag, usbdlReg, ct);

                _log("[Crasher] USBDL 寄存器已设置，等待看门狗重启...");
                return true;
            }
            catch (Exception ex)
            {
                _log($"[Crasher] Mode 3 异常: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 写入 32 位值到地址
        /// </summary>
        private async Task<bool> Write32Async(uint addr, uint value, CancellationToken ct)
        {
            // WRITE32 命令 (0xD4)
            if (!await _brom.EchoByteAsync(0xD4, ct))
                return false;

            // 地址 (大端)
            var addrBytes = BitConverter.GetBytes(addr);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(addrBytes);
            if (!await _brom.EchoBytesAsync(addrBytes, ct))
                return false;

            // 长度 = 1 (一个 dword)
            var countBytes = BitConverter.GetBytes((uint)1);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(countBytes);
            if (!await _brom.EchoBytesAsync(countBytes, ct))
                return false;

            // 读取状态
            var status = await _brom.ReadBytesAsync(2, 1000, ct);
            if (status == null) return false;

            // 写入值 (大端)
            var valueBytes = BitConverter.GetBytes(value);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(valueBytes);
            if (!await _brom.EchoBytesAsync(valueBytes, ct))
                return false;

            // 读取状态
            status = await _brom.ReadBytesAsync(2, 1000, ct);
            return status != null;
        }

        /// <summary>
        /// 等待设备重新连接并验证是否在 BROM 模式
        /// </summary>
        /// <param name="maxWaitMs">最大等待时间</param>
        /// <returns>true 如果设备重新连接且在 BROM 模式</returns>
        public async Task<bool> WaitForBromModeAsync(int maxWaitMs = 10000, CancellationToken ct = default)
        {
            _log("[Crasher] 等待设备重新连接...");

            int elapsed = 0;
            const int checkInterval = 500;

            while (elapsed < maxWaitMs)
            {
                if (ct.IsCancellationRequested) return false;

                await Task.Delay(checkInterval, ct);
                elapsed += checkInterval;

                // 检查是否有 BROM 模式的设备
                if (MtkUsbExploit.IsDeviceAvailable())
                {
                    using var usb = new MtkUsbExploit(msg => _log(msg));
                    if (usb.Connect(requireBromMode: true))
                    {
                        _log("[Crasher] ✓ 设备已重新连接，且在 BROM 模式!");
                        return true;
                    }
                }

                _log($"[Crasher] 等待中... ({elapsed}ms / {maxWaitMs}ms)");
            }

            LastError = "等待超时，设备未能进入 BROM 模式";
            _log($"[Crasher] ❌ {LastError}");
            return false;
        }
    }

    /// <summary>
    /// 老芯片 Preloader 模式的完整漏洞利用流程
    /// </summary>
    public static class OldChipPreloaderExploit
    {
        /// <summary>
        /// 对 Preloader 模式的老芯片执行完整的漏洞利用
        /// </summary>
        public static async Task<bool> RunExploitAsync(
            BromClient brom,
            byte[] payload,
            Action<string> log,
            CancellationToken ct = default)
        {
            log("═══════════════════════════════════════════════════════════════");
            log("  老芯片 Preloader 模式漏洞利用流程");
            log("═══════════════════════════════════════════════════════════════");
            log("");
            log("当前设备状态: Preloader 模式 (PID=0x2000/0x2001)");
            log("目标: 进入 BROM 模式后使用 Kamakiri2 漏洞");
            log("");

            // 步骤 1: Crash to BROM
            log("步骤 1: 让 Preloader 崩溃...");
            var crasher = new PreloaderCrasher(brom, log);
            
            if (!await crasher.CrashToBromAsync(ct))
            {
                log("❌ Crash 失败，无法进入 BROM 模式");
                log("建议: 尝试使用 DA 层漏洞 (Carbonara/AllinoneSignature)");
                return false;
            }

            // 步骤 2: 等待设备重新连接
            log("");
            log("步骤 2: 等待设备重新连接...");
            
            if (!await crasher.WaitForBromModeAsync(ct: ct))
            {
                log("❌ 设备未能进入 BROM 模式");
                return false;
            }

            // 步骤 3: 执行 Kamakiri2 漏洞
            log("");
            log("步骤 3: 执行 Kamakiri2 漏洞...");
            
            // 需要重新建立 BROM 连接
            // 这里假设调用者会重新创建 BromClient
            log("✓ 设备已在 BROM 模式，请重新连接并执行 Kamakiri2");
            
            return true;
        }

        /// <summary>
        /// 判断应该使用哪种漏洞
        /// </summary>
        public static ExploitRecommendation GetRecommendation(
            ushort vid, ushort pid, ushort hwCode, bool isBromMode)
        {
            var chip = MtkChipDatabase.GetChip(hwCode);
            
            var result = new ExploitRecommendation
            {
                HwCode = hwCode,
                ChipName = chip?.Name ?? $"Unknown (0x{hwCode:X4})",
                CurrentMode = isBromMode ? "BROM" : (pid == 0x2006 ? "DA" : "Preloader"),
                Pid = pid
            };

            // BROM 模式 (PID=0x0003)
            if (isBromMode || pid == 0x0003)
            {
                if (chip?.SupportsKamakiri2 == true)
                {
                    result.RecommendedExploit = "Kamakiri2";
                    result.CanUseDirectly = true;
                    result.Notes = "设备在 BROM 模式，可以直接使用 Kamakiri2 漏洞";
                }
                else if (Kamakiri2Exploit.IsSupported(hwCode))
                {
                    result.RecommendedExploit = "Kamakiri2";
                    result.CanUseDirectly = true;
                    result.Notes = "设备在 BROM 模式，可以直接使用 Kamakiri2 漏洞";
                }
                else
                {
                    result.RecommendedExploit = "无可用 BROM 漏洞";
                    result.CanUseDirectly = false;
                    result.Notes = $"芯片 0x{hwCode:X4} 不在 Kamakiri2 支持列表中";
                }
                return result;
            }

            // Preloader 模式 (PID=0x2000/0x2001)
            if (pid == 0x2000 || pid == 0x2001)
            {
                // ★ 优先使用 Carbonara (如果支持且未被修补)
                if (chip?.SupportsCarbonara == true && chip?.CarbonaraPatched != true)
                {
                    result.RecommendedExploit = "Carbonara";
                    result.CanUseDirectly = true;
                    result.Notes = "可以在 Preloader 模式下直接使用 Carbonara 漏洞 (串口执行, 无需 libusb)";
                    return result;
                }
                
                // ★ 次选 AllinoneSignature
                if (chip?.SupportsAllinoneSignature == true)
                {
                    result.RecommendedExploit = "AllinoneSignature";
                    result.CanUseDirectly = true;
                    result.Notes = chip?.CarbonaraPatched == true 
                        ? "Carbonara 已被修补，使用 AllinoneSignature 漏洞" 
                        : "可以在 Preloader 模式下直接使用 AllinoneSignature 漏洞";
                    return result;
                }
                
                // ★ 如果支持 Kamakiri2，需要 Crash to BROM
                if (chip?.SupportsKamakiri2 == true || Kamakiri2Exploit.IsSupported(hwCode))
                {
                    result.RecommendedExploit = "Crash to BROM → Kamakiri2";
                    result.CanUseDirectly = false;
                    result.NeedsCrashToBrom = true;
                    result.Notes = "需要先让 Preloader 崩溃进入 BROM 模式，然后使用 Kamakiri2";
                    return result;
                }
                
                // 无可用漏洞
                result.RecommendedExploit = "无可用漏洞";
                result.CanUseDirectly = false;
                result.Notes = "此芯片可能不支持已知漏洞";
                return result;
            }

            // DA 模式 (PID=0x2006)
            if (pid == 0x2006)
            {
                if (chip?.SupportsCarbonara == true && chip?.CarbonaraPatched != true)
                {
                    result.RecommendedExploit = "Carbonara";
                    result.CanUseDirectly = true;
                    result.Notes = "在 DA 模式下使用 Carbonara 漏洞";
                }
                else if (chip?.SupportsAllinoneSignature == true)
                {
                    result.RecommendedExploit = "AllinoneSignature";
                    result.CanUseDirectly = true;
                    result.Notes = "在 DA 模式下使用 AllinoneSignature 漏洞";
                }
                else
                {
                    result.RecommendedExploit = "DA 层漏洞";
                    result.CanUseDirectly = true;
                    result.Notes = "在 DA 模式下尝试 DA 层漏洞";
                }
                return result;
            }

            result.RecommendedExploit = "未知";
            result.Notes = $"未知的设备模式 (PID=0x{pid:X4})";
            return result;
        }
    }

    /// <summary>
    /// 漏洞推荐结果
    /// </summary>
    public class ExploitRecommendation
    {
        public ushort HwCode { get; set; }
        public string ChipName { get; set; }
        public string CurrentMode { get; set; }
        public ushort Pid { get; set; }
        public string RecommendedExploit { get; set; }
        public bool CanUseDirectly { get; set; }
        public bool NeedsCrashToBrom { get; set; }
        public string Notes { get; set; }

        public override string ToString()
        {
            return $@"
═══════════════════════════════════════════════════════════════
  漏洞推荐
═══════════════════════════════════════════════════════════════
  芯片: {ChipName} (0x{HwCode:X4})
  当前模式: {CurrentMode} (PID=0x{Pid:X4})
  推荐漏洞: {RecommendedExploit}
  可直接使用: {(CanUseDirectly ? "是" : "否")}
  需要 Crash to BROM: {(NeedsCrashToBrom ? "是" : "否")}
  说明: {Notes}
═══════════════════════════════════════════════════════════════";
        }
    }
}
