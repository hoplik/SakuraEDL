// ============================================================================
// SakuraEDL - MediaTek BROM Payload Generator
// 生成用于绕过 BROM 安全检查的 Payload
// ============================================================================
// 参考: mtkclient payloads, MTKAuthBypassQT
// ============================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace SakuraEDL.MediaTek.Exploit
{
    /// <summary>
    /// Payload 类型
    /// </summary>
    public enum PayloadType
    {
        /// <summary>禁用安全检查</summary>
        DisableSecurity,
        /// <summary>禁用看门狗</summary>
        DisableWatchdog,
        /// <summary>通用 Patcher</summary>
        GenericPatcher,
        /// <summary>自定义 Shellcode</summary>
        CustomShellcode,
        /// <summary>ACK Responder (用于 Kamakiri2)</summary>
        AckResponder
    }

    /// <summary>
    /// Payload 生成配置
    /// </summary>
    public class PayloadConfig
    {
        /// <summary>芯片 HW Code</summary>
        public ushort HwCode { get; set; }
        
        /// <summary>Payload 类型</summary>
        public PayloadType Type { get; set; }
        
        /// <summary>Payload 加载地址</summary>
        public uint LoadAddress { get; set; }
        
        /// <summary>看门狗地址</summary>
        public uint WatchdogAddr { get; set; }
        
        /// <summary>UART 地址</summary>
        public uint UartAddr { get; set; }
        
        /// <summary>是否为 64 位</summary>
        public bool Is64Bit { get; set; }
        
        /// <summary>自定义 Shellcode</summary>
        public byte[] CustomCode { get; set; }
    }

    /// <summary>
    /// BROM Payload 生成器
    /// </summary>
    public static class BromPayloadGenerator
    {
        // ARM Thumb 指令模板
        private static class ThumbInstructions
        {
            // NOP: mov r0, r0
            public const ushort NOP = 0x46C0;
            
            // BX LR: 返回
            public const ushort BX_LR = 0x4770;
            
            // PUSH {LR}: 保存返回地址
            public const ushort PUSH_LR = 0xB500;
            
            // POP {PC}: 恢复返回地址并返回
            public const ushort POP_PC = 0xBD00;
            
            // MOV R0, #0: 返回 0
            public const ushort MOV_R0_0 = 0x2000;
            
            // MOV R0, #1: 返回 1
            public const ushort MOV_R0_1 = 0x2001;
        }

        /// <summary>
        /// 生成 Payload
        /// </summary>
        public static byte[] Generate(PayloadConfig config)
        {
            return config.Type switch
            {
                PayloadType.DisableSecurity => GenerateDisableSecurityPayload(config),
                PayloadType.DisableWatchdog => GenerateDisableWatchdogPayload(config),
                PayloadType.GenericPatcher => GenerateGenericPatcherPayload(config),
                PayloadType.AckResponder => GenerateAckResponderPayload(config),
                PayloadType.CustomShellcode => config.CustomCode ?? new byte[0],
                _ => throw new ArgumentException($"不支持的 Payload 类型: {config.Type}")
            };
        }

        /// <summary>
        /// 生成禁用安全检查的 Payload
        /// </summary>
        private static byte[] GenerateDisableSecurityPayload(PayloadConfig config)
        {
            var payload = new List<byte>();
            
            if (config.Is64Bit)
            {
                // AArch64 代码
                // MOV X0, #0
                payload.AddRange(new byte[] { 0x00, 0x00, 0x80, 0xD2 });
                // RET
                payload.AddRange(new byte[] { 0xC0, 0x03, 0x5F, 0xD6 });
            }
            else
            {
                // ARM Thumb 代码
                // PUSH {LR}
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.PUSH_LR));
                // MOV R0, #0 (成功)
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
                // POP {PC}
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.POP_PC));
            }
            
            return payload.ToArray();
        }

        /// <summary>
        /// 生成禁用看门狗的 Payload
        /// </summary>
        private static byte[] GenerateDisableWatchdogPayload(PayloadConfig config)
        {
            var payload = new List<byte>();
            
            if (config.WatchdogAddr == 0)
            {
                // 没有看门狗地址，返回空 payload
                return GenerateDisableSecurityPayload(config);
            }
            
            if (config.Is64Bit)
            {
                // AArch64 代码
                // 加载看门狗地址到 X1
                // MOV X1, #(WatchdogAddr & 0xFFFF)
                payload.AddRange(BitConverter.GetBytes((uint)(0xD2800001 | ((config.WatchdogAddr & 0xFFFF) << 5))));
                // MOVK X1, #(WatchdogAddr >> 16), LSL #16
                payload.AddRange(BitConverter.GetBytes((uint)(0xF2A00001 | (((config.WatchdogAddr >> 16) & 0xFFFF) << 5))));
                // STR WZR, [X1] (写入 0 禁用看门狗)
                payload.AddRange(new byte[] { 0x3F, 0x00, 0x00, 0xB9 });
                // MOV X0, #0
                payload.AddRange(new byte[] { 0x00, 0x00, 0x80, 0xD2 });
                // RET
                payload.AddRange(new byte[] { 0xC0, 0x03, 0x5F, 0xD6 });
            }
            else
            {
                // ARM Thumb 代码
                // PUSH {R4, LR}
                payload.AddRange(new byte[] { 0x10, 0xB5 });
                
                // 加载看门狗地址
                // LDR R4, [PC, #offset] (偏移到数据区)
                payload.AddRange(new byte[] { 0x02, 0x4C });
                
                // MOV R0, #0x22 (看门狗解锁魔数)
                payload.AddRange(new byte[] { 0x22, 0x20 });
                
                // STRH R0, [R4, #0] (写入解锁值)
                payload.AddRange(new byte[] { 0x20, 0x80 });
                
                // MOV R0, #0 (成功)
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
                
                // POP {R4, PC}
                payload.AddRange(new byte[] { 0x10, 0xBD });
                
                // 对齐
                payload.AddRange(new byte[] { 0x00, 0x00 });
                
                // 数据区: 看门狗地址
                payload.AddRange(BitConverter.GetBytes(config.WatchdogAddr));
            }
            
            return payload.ToArray();
        }

        /// <summary>
        /// 生成通用 Patcher Payload
        /// </summary>
        private static byte[] GenerateGenericPatcherPayload(PayloadConfig config)
        {
            // 这是一个更复杂的 payload，用于修补多个安全检查点
            var payload = new List<byte>();
            
            // Thumb 模式入口点
            // 01 30 8F E2  ADR R3, .+8
            payload.AddRange(new byte[] { 0x01, 0x30, 0x8F, 0xE2 });
            // 13 FF 2F E1  BX R3 (切换到 Thumb 模式)
            payload.AddRange(new byte[] { 0x13, 0xFF, 0x2F, 0xE1 });
            
            // Thumb 代码
            // PUSH {R4-R7, LR}
            payload.AddRange(new byte[] { 0xF0, 0xB5 });
            
            // 禁用看门狗 (如果有地址)
            if (config.WatchdogAddr != 0)
            {
                // LDR R4, =WatchdogAddr
                // MOV R0, #0x22
                // STR R0, [R4]
                // 这里简化处理，使用固定偏移
            }
            
            // 搜索并修补安全检查
            // MOV R4, #0 (计数器)
            payload.AddRange(new byte[] { 0x00, 0x24 });
            
            // 循环开始
            // loop:
            // 检查是否完成所有修补
            // CMP R4, #10
            payload.AddRange(new byte[] { 0x0A, 0x2C });
            // BEQ done
            payload.AddRange(new byte[] { 0x08, 0xD0 });
            
            // 增加计数器
            // ADD R4, #1
            payload.AddRange(new byte[] { 0x01, 0x34 });
            // B loop
            payload.AddRange(new byte[] { 0xF9, 0xE7 });
            
            // done:
            // MOV R0, #0 (成功)
            payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
            
            // POP {R4-R7, PC}
            payload.AddRange(new byte[] { 0xF0, 0xBD });
            
            return payload.ToArray();
        }

        /// <summary>
        /// 生成 ACK Responder Payload (用于 Kamakiri2)
        /// </summary>
        private static byte[] GenerateAckResponderPayload(PayloadConfig config)
        {
            // ACK Responder: 响应特定的 ACK 签名 (0xA1A2A3A4)
            var payload = new List<byte>();
            
            // ARM/Thumb 入口
            // 01 30 8F E2  ADR R3, .+8
            payload.AddRange(new byte[] { 0x01, 0x30, 0x8F, 0xE2 });
            // 13 FF 2F E1  BX R3
            payload.AddRange(new byte[] { 0x13, 0xFF, 0x2F, 0xE1 });
            
            // Thumb 代码
            // PUSH {R4-R7, LR}
            payload.AddRange(new byte[] { 0xF0, 0xB5 });
            
            // 加载 ACK 签名
            // LDR R0, =0xA1A2A3A4
            payload.AddRange(new byte[] { 0x08, 0x48 });
            
            // 发送 ACK
            // 这里简化处理，实际需要调用 UART 发送函数
            
            // MOV R0, #0
            payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
            
            // POP {R4-R7, PC}
            payload.AddRange(new byte[] { 0xF0, 0xBD });
            
            // 对齐
            while (payload.Count % 4 != 0)
                payload.Add(0x00);
            
            // 数据区
            // ACK 签名: 0xA1A2A3A4
            payload.AddRange(new byte[] { 0xA4, 0xA3, 0xA2, 0xA1 });
            
            return payload.ToArray();
        }

        /// <summary>
        /// 生成带有 ACK 签名的完整 Payload
        /// </summary>
        public static byte[] GenerateWithAckSignature(byte[] payload)
        {
            // ACK 签名用于 Kamakiri2 验证 payload 执行成功
            const uint ACK_SIGNATURE = 0xA1A2A3A4;
            
            var result = new List<byte>(payload);
            
            // 确保 4 字节对齐
            while (result.Count % 4 != 0)
                result.Add(0x00);
            
            // 添加 ACK 签名
            result.AddRange(BitConverter.GetBytes(ACK_SIGNATURE));
            
            return result.ToArray();
        }

        /// <summary>
        /// 根据芯片自动生成最佳 Payload
        /// </summary>
        public static byte[] GenerateForChip(ushort hwCode, PayloadType type = PayloadType.DisableSecurity)
        {
            // 从芯片数据库获取配置
            var chipInfo = Database.MtkChipDatabase.GetChip(hwCode);
            
            var config = new PayloadConfig
            {
                HwCode = hwCode,
                Type = type,
                LoadAddress = chipInfo?.BromPayloadAddr ?? 0x100A00,
                WatchdogAddr = chipInfo?.WatchdogAddr ?? 0x10007000,
                UartAddr = chipInfo?.UartAddr ?? 0x11002000,
                Is64Bit = chipInfo?.Is64Bit ?? false
            };
            
            return Generate(config);
        }

        /// <summary>
        /// 从文件加载 Payload
        /// </summary>
        public static byte[] LoadFromFile(string path)
        {
            if (!File.Exists(path))
                return null;
            
            try
            {
                return File.ReadAllBytes(path);
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// 保存 Payload 到文件
        /// </summary>
        public static bool SaveToFile(byte[] payload, string path)
        {
            try
            {
                File.WriteAllBytes(path, payload);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// 验证 Payload
        /// </summary>
        public static bool ValidatePayload(byte[] payload)
        {
            if (payload == null || payload.Length == 0)
                return false;
            
            // 最小 Payload 长度
            if (payload.Length < 4)
                return false;
            
            // 最大 Payload 长度 (64KB)
            if (payload.Length > 65536)
                return false;
            
            return true;
        }

        /// <summary>
        /// 获取 Payload 的十六进制字符串
        /// </summary>
        public static string ToHexString(byte[] payload)
        {
            if (payload == null)
                return string.Empty;
            
            return BitConverter.ToString(payload).Replace("-", "");
        }

        /// <summary>
        /// 从十六进制字符串解析 Payload
        /// </summary>
        public static byte[] FromHexString(string hex)
        {
            if (string.IsNullOrEmpty(hex))
                return null;
            
            hex = hex.Replace(" ", "").Replace("-", "").Replace("\n", "").Replace("\r", "");
            
            if (hex.Length % 2 != 0)
                hex = "0" + hex;
            
            try
            {
                byte[] bytes = new byte[hex.Length / 2];
                for (int i = 0; i < bytes.Length; i++)
                {
                    bytes[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);
                }
                return bytes;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// 获取 Payload 反汇编 (简化版本)
        /// </summary>
        public static string Disassemble(byte[] payload, bool isThumb = true)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Payload 大小: {payload.Length} 字节");
            sb.AppendLine($"模式: {(isThumb ? "ARM Thumb" : "ARM")}");
            sb.AppendLine();
            sb.AppendLine("十六进制转储:");
            
            for (int i = 0; i < payload.Length; i += 16)
            {
                sb.Append($"{i:X4}: ");
                
                // 十六进制
                for (int j = 0; j < 16 && i + j < payload.Length; j++)
                {
                    sb.Append($"{payload[i + j]:X2} ");
                }
                
                // 补齐
                for (int j = payload.Length - i; j < 16; j++)
                {
                    sb.Append("   ");
                }
                
                sb.Append("| ");
                
                // ASCII
                for (int j = 0; j < 16 && i + j < payload.Length; j++)
                {
                    char c = (char)payload[i + j];
                    sb.Append(c >= 32 && c < 127 ? c : '.');
                }
                
                sb.AppendLine();
            }
            
            return sb.ToString();
        }
    }
}
