// ============================================================================
// LoveAlways - 漏洞利用服务
// 集成芯片信息读取和漏洞利用
// ============================================================================

using System;
using System.IO.Ports;
using System.Threading;
using System.Threading.Tasks;
using LoveAlways.Qualcomm.Database;

namespace LoveAlways.Qualcomm.Exploit
{
    /// <summary>
    /// 漏洞利用服务 - 提供高级接口
    /// </summary>
    public class ExploitService
    {
        private readonly Action<string> _log;
        private readonly PblExploit _exploit;
        
        // 最近一次漏洞检测结果
        public VulnerabilityCheckResult LastCheckResult { get; private set; }
        
        // 是否启用漏洞利用
        public bool EnableExploit { get; set; }

        public ExploitService(Action<string> log = null)
        {
            _log = log ?? delegate { };
            _exploit = new PblExploit(_log);
            EnableExploit = false;  // 默认禁用
        }

        /// <summary>
        /// 检查芯片是否有可用漏洞 (在 Sahara 握手后调用)
        /// </summary>
        /// <param name="chipInfo">通过 SaharaClient 读取的芯片信息</param>
        /// <returns>是否有可用漏洞</returns>
        public bool CheckAndReportVulnerabilities(QualcommChipInfo chipInfo)
        {
            if (chipInfo == null)
            {
                _log("[ExploitService] 无芯片信息，跳过漏洞检测");
                return false;
            }

            LastCheckResult = _exploit.CheckVulnerability(chipInfo);
            
            if (LastCheckResult.HasVulnerability)
            {
                // 通知用户有可用漏洞
                _log("");
                _log("╔══════════════════════════════════════════╗");
                _log("║       检测到可用漏洞 / Exploit Found     ║");
                _log("╠══════════════════════════════════════════╣");
                _log(string.Format("║ 芯片: {0,-32} ║", chipInfo.ChipName ?? "Unknown"));
                _log(string.Format("║ 推荐: {0,-32} ║", LastCheckResult.RecommendedExploit ?? "N/A"));
                _log("╠══════════════════════════════════════════╣");
                _log("║ 如需使用漏洞利用，请启用相关选项         ║");
                _log("╚══════════════════════════════════════════╝");
                _log("");
            }

            return LastCheckResult.HasVulnerability;
        }

        /// <summary>
        /// 尝试利用漏洞 (如果已启用且有可用漏洞)
        /// </summary>
        /// <param name="port">串口</param>
        /// <param name="chipInfo">芯片信息</param>
        /// <param name="ct">取消令牌</param>
        /// <returns>利用结果</returns>
        public async Task<ExploitResult> TryExploitIfEnabledAsync(
            SerialPort port,
            QualcommChipInfo chipInfo,
            CancellationToken ct = default(CancellationToken))
        {
            // 检查是否启用
            if (!EnableExploit)
            {
                _log("[ExploitService] 漏洞利用未启用");
                return new ExploitResult { Success = false, Message = "漏洞利用未启用" };
            }

            // 检查是否有可用漏洞
            if (LastCheckResult == null || !LastCheckResult.HasVulnerability)
            {
                var checkResult = CheckAndReportVulnerabilities(chipInfo);
                if (!checkResult)
                {
                    return new ExploitResult { Success = false, Message = "无可用漏洞" };
                }
            }

            // 执行漏洞利用
            _log("[ExploitService] 开始执行漏洞利用...");
            return await _exploit.TryExploitWithChipInfoAsync(port, chipInfo, ct);
        }

        /// <summary>
        /// 获取漏洞利用建议
        /// </summary>
        public string GetExploitRecommendation(QualcommChipInfo chipInfo)
        {
            if (chipInfo == null)
                return "无芯片信息";

            var result = ExploitDatabase.CheckVulnerabilities(
                chipInfo.MsmId,
                chipInfo.OemId,
                chipInfo.PkHash,
                0
            );

            if (!result.HasVulnerability)
                return "该设备无已知漏洞";

            return string.Format("推荐使用: {0}\n原因: {1}",
                result.RecommendedExploit,
                result.Reason);
        }

        /// <summary>
        /// 快速检查芯片是否可能有漏洞 (不需要完整芯片信息)
        /// </summary>
        public static bool QuickCheckByMsmId(uint msmId)
        {
            return ExploitDatabase.IsChipPotentiallyVulnerable(msmId);
        }

        /// <summary>
        /// 获取芯片漏洞描述
        /// </summary>
        public static string GetChipVulnDescription(uint msmId)
        {
            return ExploitDatabase.GetChipVulnerabilityDescription(msmId);
        }
    }
}
