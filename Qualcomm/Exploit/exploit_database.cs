// ============================================================================
// SakuraEDL - Exploit Database | 漏洞数据库
// ============================================================================
// [ZH] 漏洞数据库 - 记录已知的有漏洞芯片和厂商信息
// [EN] Exploit Database - Record known vulnerable chips and vendor info
// [JA] エクスプロイトDB - 既知の脆弱性チップとベンダー情報を記録
// [KO] 익스플로잇 DB - 알려진 취약 칩 및 벤더 정보 기록
// [RU] База эксплойтов - Запись известных уязвимых чипов и вендоров
// [ES] Base de exploits - Registrar chips vulnerables conocidos e info
// ============================================================================
// Copyright (c) 2025-2026 SakuraEDL | MIT License
// ============================================================================

using System;
using System.Collections.Generic;

namespace SakuraEDL.Qualcomm.Exploit
{
    /// <summary>
    /// 漏洞信息
    /// </summary>
    public class VulnerabilityInfo
    {
        public ExploitType Type { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] AffectedChips { get; set; }
        public string[] AffectedVendors { get; set; }
        public uint[] AffectedPblVersions { get; set; }
        public int SuccessRate { get; set; }  // 1-5 星
    }

    /// <summary>
    /// 漏洞检测结果
    /// </summary>
    public class VulnerabilityCheckResult
    {
        public bool HasVulnerability { get; set; }
        public List<VulnerabilityInfo> AvailableExploits { get; set; }
        public string RecommendedExploit { get; set; }
        public string Reason { get; set; }

        public VulnerabilityCheckResult()
        {
            AvailableExploits = new List<VulnerabilityInfo>();
        }
    }

    /// <summary>
    /// 漏洞数据库
    /// </summary>
    public static class ExploitDatabase
    {
        // ============================================================================
        // 已知有漏洞的芯片 (MSM ID)
        // ============================================================================
        private static readonly Dictionary<uint, VulnerabilityInfo> VulnerableChips = new Dictionary<uint, VulnerabilityInfo>
        {
            // ======================= Snapdragon 8xx 系列 =======================
            
            // SDM845 - Sahara Memory Debug 漏洞
            { 0x0008B0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Memory Debug",
                Description = "SDM845 部分批次允许进入 Memory Debug 模式",
                AffectedChips = new[] { "SDM845", "SDA845" },
                SuccessRate = 3
            }},
            
            // MSM8998 - Sahara ReadData 溢出
            { 0x0005E0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara ReadData Overflow",
                Description = "MSM8998 (Snapdragon 835) 部分版本存在 ReadData 缓冲区溢出",
                AffectedChips = new[] { "MSM8998", "APQ8098" },
                SuccessRate = 3
            }},
            
            // MSM8996/MSM8996Pro - 经典 EDL 漏洞
            { 0x009470E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit",
                Description = "MSM8996 (Snapdragon 820) 存在多个已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8996", "APQ8096" },
                SuccessRate = 4
            }},
            { 0x0005F0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit (821)",
                Description = "MSM8996Pro (Snapdragon 821) 存在已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8996Pro" },
                SuccessRate = 4
            }},
            
            // MSM8994 - Snapdragon 810 漏洞
            { 0x009400E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Exploit (810)",
                Description = "MSM8994 (Snapdragon 810) 旧版 PBL 存在漏洞",
                AffectedChips = new[] { "MSM8994", "APQ8094" },
                SuccessRate = 4
            }},
            
            // ======================= Snapdragon 7xx 系列 =======================
            
            // SDM710 - Firehose 隐藏命令
            { 0x000DB0E1, new VulnerabilityInfo {
                Type = ExploitType.FirehoseXmlOverflow,
                Name = "Firehose Hidden Commands",
                Description = "SDM710 (Snapdragon 710) 部分设备支持 peek/poke 调试命令",
                AffectedChips = new[] { "SDM710", "SDA710" },
                SuccessRate = 2
            }},
            
            // SDM670 - 签名绕过 (部分 unfused)
            { 0x000910E1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused Device",
                Description = "SDM670 (Snapdragon 670) 部分工程机未烧录安全熔丝",
                AffectedChips = new[] { "SDM670", "SDA670" },
                SuccessRate = 4
            }},
            
            // SDM660 - 签名绕过
            { 0x0008C0E1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Loader Signature Bypass",
                Description = "SDM660 (Snapdragon 660) 部分版本可加载未签名 Loader",
                AffectedChips = new[] { "SDM660", "SDA660" },
                SuccessRate = 3
            }},
            
            // ======================= Snapdragon 6xx 系列 =======================
            
            // SDM636/632 - Sahara 漏洞
            { 0x000CC0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "SDM636 (Snapdragon 636) 部分版本存在 Sahara 协议漏洞",
                AffectedChips = new[] { "SDM636", "SDA636" },
                SuccessRate = 3
            }},
            { 0x000BA0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "SDM632 (Snapdragon 632) 部分版本存在 Sahara 协议漏洞",
                AffectedChips = new[] { "SDM632", "SDA632" },
                SuccessRate = 3
            }},
            
            // SDM630 - 签名绕过
            { 0x000AC0E1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Loader Signature Bypass",
                Description = "SDM630 (Snapdragon 630) 部分版本可加载未签名 Loader",
                AffectedChips = new[] { "SDM630", "SDA630" },
                SuccessRate = 3
            }},
            
            // ======================= Snapdragon 4xx/2xx 系列 =======================
            
            // MSM8953 - Sahara 漏洞
            { 0x000460E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8953 (Snapdragon 625) 部分版本存在 Sahara 协议漏洞",
                AffectedChips = new[] { "MSM8953", "APQ8053" },
                SuccessRate = 3
            }},
            
            // MSM8937 - 旧版 PBL 漏洞
            { 0x0004F0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy PBL Exploit",
                Description = "MSM8937 (Snapdragon 430) 旧版 PBL 存在多个漏洞",
                AffectedChips = new[] { "MSM8937", "APQ8037" },
                SuccessRate = 4
            }},
            
            // MSM8917 - Sahara 漏洞
            { 0x000510E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8917 (Snapdragon 425) 部分版本存在 Sahara 协议漏洞",
                AffectedChips = new[] { "MSM8917", "APQ8017" },
                SuccessRate = 3
            }},
            
            // MSM8916 - 经典漏洞
            { 0x007050E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit",
                Description = "MSM8916 (Snapdragon 410) 存在多个已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8916", "APQ8016", "MSM8216", "MSM8116" },
                SuccessRate = 5
            }},
            
            // MSM8909 - 入门级芯片漏洞
            { 0x009600E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8909 (Snapdragon 210) 旧版 PBL 存在漏洞",
                AffectedChips = new[] { "MSM8909", "APQ8009" },
                SuccessRate = 4
            }},
            
            // ======================= 旧 MSM 系列 =======================
            
            // MSM8974 - Snapdragon 800/801
            { 0x007B00E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy EDL Exploit",
                Description = "MSM8974 (Snapdragon 800) 存在多个已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8974", "APQ8074" },
                SuccessRate = 5
            }},
            { 0x007B20E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy EDL Exploit",
                Description = "MSM8974-AB (Snapdragon 801) 存在多个已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8974-AB" },
                SuccessRate = 5
            }},
            
            // MSM8926/8926 - Snapdragon 400
            { 0x007100E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy EDL Exploit",
                Description = "MSM8926 (Snapdragon 400) 存在已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8926", "MSM8226", "MSM8626" },
                SuccessRate = 5
            }},
            
            // MSM8939 - Snapdragon 615/616
            { 0x009290E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8939 (Snapdragon 615) 存在 Sahara 协议漏洞",
                AffectedChips = new[] { "MSM8939", "APQ8039" },
                SuccessRate = 4
            }},
            
            // MSM8976 - Snapdragon 652
            { 0x009900E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8976 (Snapdragon 652) 部分版本存在 Sahara 漏洞",
                AffectedChips = new[] { "MSM8976", "APQ8076" },
                SuccessRate = 3
            }},
            
            // MSM8952 - Snapdragon 617
            { 0x009720E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8952 (Snapdragon 617) 部分版本存在 Sahara 漏洞",
                AffectedChips = new[] { "MSM8952" },
                SuccessRate = 3
            }},
        };

        // ============================================================================
        // 已知有漏洞的厂商 OEM ID
        // ============================================================================
        private static readonly Dictionary<ushort, VulnerabilityInfo> VulnerableVendors = new Dictionary<ushort, VulnerabilityInfo>
        {
            // 未熔断设备
            { 0x0000, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused/Engineering Device",
                Description = "OEM ID 为 0，可能是工程机或 unfused 设备",
                AffectedVendors = new[] { "Unknown/Engineering" },
                SuccessRate = 5
            }},
            
            // 高通官方测试设备
            { 0x0001, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Qualcomm Test Device",
                Description = "高通测试设备，可能使用测试密钥",
                AffectedVendors = new[] { "Qualcomm Test" },
                SuccessRate = 4
            }},
        };

        // ============================================================================
        // 已知可能存在漏洞的厂商 (历史上曾泄露 Loader)
        // ============================================================================
        private static readonly HashSet<ushort> PotentiallyVulnerableVendors = new HashSet<ushort>
        {
            0x0020,  // Samsung (部分旧设备)
            0x0029,  // Asus
            0x0031,  // LG
            0x0072,  // Xiaomi (部分旧设备泄露 Loader)
            0x0051,  // Oppo/OnePlus (部分版本)
            0x00C8,  // Motorola
            0x0017,  // Lenovo
        };

        // ============================================================================
        // 已知有漏洞的 PK Hash 前缀
        // ============================================================================
        private static readonly Dictionary<string, VulnerabilityInfo> VulnerablePkHash = new Dictionary<string, VulnerabilityInfo>
        {
            // 未熔断/测试设备
            { "00000000", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Test Key / Unfused",
                Description = "PK Hash 全零，设备未熔断或使用测试密钥",
                SuccessRate = 5
            }},
            
            // 全 F (另一种未熔断标志)
            { "ffffffff", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused Device (All F)",
                Description = "PK Hash 全 F，设备未熔断",
                SuccessRate = 5
            }},
            
            // 高通测试密钥 (已知泄露)
            { "cc3153a8", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Qualcomm Test Key",
                Description = "使用高通测试密钥，可能加载通用 Loader",
                SuccessRate = 4
            }},
            { "7be49b72", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Qualcomm Debug Key",
                Description = "使用高通调试密钥，可能加载通用 Loader",
                SuccessRate = 4
            }},
        };

        // ============================================================================
        // 已知有漏洞的 PBL 版本
        // ============================================================================
        private static readonly Dictionary<uint, VulnerabilityInfo> VulnerablePblVersions = new Dictionary<uint, VulnerabilityInfo>
        {
            { 0x00000001, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "PBL v1 Sahara Exploit",
                Description = "PBL 版本 1 存在 Sahara 协议漏洞",
                SuccessRate = 4
            }},
            { 0x00000002, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "PBL v2 Sahara Exploit",
                Description = "PBL 版本 2 存在 Sahara 协议漏洞",
                SuccessRate = 3
            }},
        };

        /// <summary>
        /// 根据芯片信息检测可用漏洞
        /// </summary>
        /// <param name="msmId">MSM ID (芯片ID)</param>
        /// <param name="oemId">OEM ID (厂商ID)</param>
        /// <param name="pkHash">PK Hash (前8位即可)</param>
        /// <param name="pblVersion">PBL 版本 (可选)</param>
        /// <returns>漏洞检测结果</returns>
        public static VulnerabilityCheckResult CheckVulnerabilities(
            uint msmId, 
            ushort oemId, 
            string pkHash, 
            uint pblVersion = 0)
        {
            var result = new VulnerabilityCheckResult();

            // 1. 检查芯片是否有已知漏洞
            VulnerabilityInfo chipVuln;
            if (VulnerableChips.TryGetValue(msmId, out chipVuln))
            {
                result.HasVulnerability = true;
                result.AvailableExploits.Add(chipVuln);
            }

            // 2. 检查厂商是否有已知漏洞
            VulnerabilityInfo vendorVuln;
            if (VulnerableVendors.TryGetValue(oemId, out vendorVuln))
            {
                result.HasVulnerability = true;
                result.AvailableExploits.Add(vendorVuln);
            }

            // 3. 检查 PK Hash 是否有已知漏洞
            if (!string.IsNullOrEmpty(pkHash) && pkHash.Length >= 8)
            {
                string prefix = pkHash.Substring(0, 8).ToLower();
                VulnerabilityInfo pkVuln;
                if (VulnerablePkHash.TryGetValue(prefix, out pkVuln))
                {
                    result.HasVulnerability = true;
                    result.AvailableExploits.Add(pkVuln);
                }
            }

            // 4. 检查 PBL 版本是否有已知漏洞
            if (pblVersion > 0)
            {
                VulnerabilityInfo pblVuln;
                if (VulnerablePblVersions.TryGetValue(pblVersion, out pblVuln))
                {
                    result.HasVulnerability = true;
                    result.AvailableExploits.Add(pblVuln);
                }
            }

            // 5. 确定推荐的漏洞利用方式
            if (result.HasVulnerability && result.AvailableExploits.Count > 0)
            {
                // 按成功率排序，选择最高的
                VulnerabilityInfo best = result.AvailableExploits[0];
                foreach (var vuln in result.AvailableExploits)
                {
                    if (vuln.SuccessRate > best.SuccessRate)
                        best = vuln;
                }
                result.RecommendedExploit = best.Name;
                result.Reason = best.Description;
            }

            return result;
        }

        /// <summary>
        /// 获取芯片的漏洞描述
        /// </summary>
        public static string GetChipVulnerabilityDescription(uint msmId)
        {
            VulnerabilityInfo info;
            if (VulnerableChips.TryGetValue(msmId, out info))
            {
                return string.Format("{0} ({1}★)", info.Name, info.SuccessRate);
            }
            return null;
        }

        /// <summary>
        /// 判断芯片是否可能有漏洞
        /// </summary>
        public static bool IsChipPotentiallyVulnerable(uint msmId)
        {
            // 已知有漏洞的芯片
            if (VulnerableChips.ContainsKey(msmId))
                return true;

            // 2018年之前的芯片更可能有漏洞
            // MSM8xxx 系列 (旧架构)
            if ((msmId & 0x00FF0000) == 0)
                return true;

            return false;
        }

        /// <summary>
        /// 判断是否为 unfused 设备
        /// </summary>
        public static bool IsUnfusedDevice(ushort oemId, string pkHash)
        {
            // OEM ID 为 0
            if (oemId == 0)
                return true;

            // PK Hash 全零或全 F
            if (!string.IsNullOrEmpty(pkHash))
            {
                string lower = pkHash.ToLowerInvariant();
                if (lower.StartsWith("00000000") || lower.StartsWith("ffffffff"))
                    return true;
                    
                // 检查是否全部为同一字符
                if (lower.Length >= 8)
                {
                    char first = lower[0];
                    bool allSame = true;
                    for (int i = 1; i < 8 && allSame; i++)
                    {
                        if (lower[i] != first)
                            allSame = false;
                    }
                    if (allSame)
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// 检查厂商是否可能有泄露的 Loader
        /// </summary>
        public static bool IsVendorPotentiallyVulnerable(ushort oemId)
        {
            return VulnerableVendors.ContainsKey(oemId) || PotentiallyVulnerableVendors.Contains(oemId);
        }

        /// <summary>
        /// 获取芯片的漏洞利用建议
        /// </summary>
        public static ExploitRecommendation GetExploitRecommendation(uint msmId, ushort oemId, string pkHash, uint pblVersion)
        {
            var rec = new ExploitRecommendation();
            var checkResult = CheckVulnerabilities(msmId, oemId, pkHash, pblVersion);
            
            rec.HasKnownVulnerability = checkResult.HasVulnerability;
            rec.AvailableExploits = checkResult.AvailableExploits;
            
            // 1. Unfused 设备 - 直接加载未签名 Loader
            if (IsUnfusedDevice(oemId, pkHash))
            {
                rec.Strategy = ExploitStrategy.LoadUnsignedLoader;
                rec.Description = "设备未熔断，可直接加载未签名 Loader";
                rec.SuccessChance = 95;
                return rec;
            }
            
            // 2. 检查是否有芯片特定漏洞
            if (checkResult.HasVulnerability && checkResult.AvailableExploits.Count > 0)
            {
                var best = checkResult.AvailableExploits[0];
                foreach (var vuln in checkResult.AvailableExploits)
                {
                    if (vuln.SuccessRate > best.SuccessRate)
                        best = vuln;
                }
                
                rec.Strategy = GetStrategyFromExploitType(best.Type);
                rec.Description = best.Description;
                rec.SuccessChance = best.SuccessRate * 20; // 转换为百分比
                return rec;
            }
            
            // 3. 检查是否有泄露的 Loader
            if (IsVendorPotentiallyVulnerable(oemId))
            {
                rec.Strategy = ExploitStrategy.UseLeakedLoader;
                rec.Description = "该厂商可能有泄露的 Loader 可用";
                rec.SuccessChance = 50;
                return rec;
            }
            
            // 4. 无已知漏洞
            rec.Strategy = ExploitStrategy.None;
            rec.Description = "未检测到已知漏洞，需要签名 Loader 或厂商认证";
            rec.SuccessChance = 10;
            
            return rec;
        }

        private static ExploitStrategy GetStrategyFromExploitType(ExploitType type)
        {
            switch (type)
            {
                case ExploitType.SignatureBypass:
                    return ExploitStrategy.LoadUnsignedLoader;
                case ExploitType.SaharaOverflow:
                    return ExploitStrategy.SaharaExploit;
                case ExploitType.FirehoseXmlOverflow:
                    return ExploitStrategy.FirehoseExploit;
                case ExploitType.PblBufferOverflow:
                    return ExploitStrategy.PblExploit;
                default:
                    return ExploitStrategy.None;
            }
        }

        /// <summary>
        /// 获取所有已知有漏洞的芯片列表
        /// </summary>
        public static List<uint> GetAllVulnerableChipIds()
        {
            return new List<uint>(VulnerableChips.Keys);
        }

        /// <summary>
        /// 获取漏洞数据库统计信息
        /// </summary>
        public static ExploitDatabaseStats GetStats()
        {
            var stats = new ExploitDatabaseStats();
            stats.TotalVulnerableChips = VulnerableChips.Count;
            stats.TotalVulnerableVendors = VulnerableVendors.Count;
            stats.TotalVulnerablePkHashes = VulnerablePkHash.Count;
            stats.TotalVulnerablePblVersions = VulnerablePblVersions.Count;
            
            // 按漏洞类型统计
            foreach (var vuln in VulnerableChips.Values)
            {
                if (!stats.ChipsByExploitType.ContainsKey(vuln.Type))
                    stats.ChipsByExploitType[vuln.Type] = 0;
                stats.ChipsByExploitType[vuln.Type]++;
            }
            
            return stats;
        }
    }

    /// <summary>
    /// 漏洞利用策略
    /// </summary>
    public enum ExploitStrategy
    {
        None,                   // 无可用策略
        LoadUnsignedLoader,     // 直接加载未签名 Loader
        UseLeakedLoader,        // 使用泄露的 Loader
        SaharaExploit,          // Sahara 协议漏洞
        FirehoseExploit,        // Firehose 漏洞
        PblExploit              // PBL 漏洞
    }

    /// <summary>
    /// 漏洞利用建议
    /// </summary>
    public class ExploitRecommendation
    {
        public bool HasKnownVulnerability { get; set; }
        public ExploitStrategy Strategy { get; set; }
        public string Description { get; set; }
        public int SuccessChance { get; set; }  // 0-100
        public List<VulnerabilityInfo> AvailableExploits { get; set; }
        
        public ExploitRecommendation()
        {
            AvailableExploits = new List<VulnerabilityInfo>();
            Strategy = ExploitStrategy.None;
            Description = "";
            SuccessChance = 0;
        }
        
        public override string ToString()
        {
            return string.Format("Strategy: {0}, Success: {1}%, Desc: {2}", 
                Strategy, SuccessChance, Description);
        }
    }

    /// <summary>
    /// 漏洞数据库统计信息
    /// </summary>
    public class ExploitDatabaseStats
    {
        public int TotalVulnerableChips { get; set; }
        public int TotalVulnerableVendors { get; set; }
        public int TotalVulnerablePkHashes { get; set; }
        public int TotalVulnerablePblVersions { get; set; }
        public Dictionary<ExploitType, int> ChipsByExploitType { get; set; }
        
        public ExploitDatabaseStats()
        {
            ChipsByExploitType = new Dictionary<ExploitType, int>();
        }
        
        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine("漏洞数据库统计:");
            sb.AppendLine(string.Format("  已知有漏洞芯片数: {0}", TotalVulnerableChips));
            sb.AppendLine(string.Format("  已知有漏洞厂商数: {0}", TotalVulnerableVendors));
            sb.AppendLine(string.Format("  已知有漏洞 PK Hash 数: {0}", TotalVulnerablePkHashes));
            sb.AppendLine(string.Format("  已知有漏洞 PBL 版本数: {0}", TotalVulnerablePblVersions));
            sb.AppendLine("  按漏洞类型分布:");
            foreach (var kvp in ChipsByExploitType)
            {
                sb.AppendLine(string.Format("    {0}: {1}", kvp.Key, kvp.Value));
            }
            return sb.ToString();
        }
    }
}
